{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); /// <reference types=\"node\"/>\n\nvar int64_buffer_1 = require(\"int64-buffer\");\n\nvar EBMLEncoder_1 = require(\"./EBMLEncoder\");\n\nvar _Buffer = require(\"buffer/\");\n\nvar _tools = require(\"ebml/lib/ebml/tools\");\n\nvar _block = require(\"ebml-block\");\n\nexports.Buffer = _Buffer.Buffer;\nexports.readVint = _tools.readVint;\nexports.writeVint = _tools.writeVint;\nexports.ebmlBlock = _block;\n\nfunction readBlock(buf) {\n  return exports.ebmlBlock(new exports.Buffer(buf));\n}\n\nexports.readBlock = readBlock;\n/**\n  * @param end - if end === false then length is unknown\n  */\n\nfunction encodeTag(tagId, tagData, unknownSize) {\n  if (unknownSize === void 0) {\n    unknownSize = false;\n  }\n\n  return concat([tagId, unknownSize ? new exports.Buffer('01ffffffffffffff', 'hex') : exports.writeVint(tagData.length), tagData]);\n}\n\nexports.encodeTag = encodeTag;\n/**\n * @return - SimpleBlock to WebP Filter\n */\n\nfunction WebPFrameFilter(elms) {\n  return WebPBlockFilter(elms).reduce(function (lst, elm) {\n    var o = exports.ebmlBlock(elm.data);\n    return o.frames.reduce(function (lst, frame) {\n      // https://developers.Blob.com/speed/webp/docs/riff_container\n      var webpBuf = VP8BitStreamToRiffWebPBuffer(frame);\n      var webp = new Blob([webpBuf], {\n        type: \"image/webp\"\n      });\n      return lst.concat(webp);\n    }, lst);\n  }, []);\n}\n\nexports.WebPFrameFilter = WebPFrameFilter;\n/**\n * WebP ファイルにできる SimpleBlock の パスフィルタ\n */\n\nfunction WebPBlockFilter(elms) {\n  return elms.reduce(function (lst, elm) {\n    if (elm.type !== \"b\") {\n      return lst;\n    }\n\n    if (elm.name !== \"SimpleBlock\") {\n      return lst;\n    }\n\n    var o = exports.ebmlBlock(elm.data);\n    var hasWebP = o.frames.some(function (frame) {\n      // https://tools.ietf.org/html/rfc6386#section-19.1\n      var startcode = frame.slice(3, 6).toString(\"hex\");\n      return startcode === \"9d012a\";\n    });\n\n    if (!hasWebP) {\n      return lst;\n    }\n\n    return lst.concat(elm);\n  }, []);\n}\n\nexports.WebPBlockFilter = WebPBlockFilter;\n/**\n * @param frame - VP8 BitStream のうち startcode をもつ frame\n * @return - WebP ファイルの ArrayBuffer\n */\n\nfunction VP8BitStreamToRiffWebPBuffer(frame) {\n  var VP8Chunk = createRIFFChunk(\"VP8 \", frame);\n  var WebPChunk = concat([new exports.Buffer(\"WEBP\", \"ascii\"), VP8Chunk]);\n  return createRIFFChunk(\"RIFF\", WebPChunk);\n}\n\nexports.VP8BitStreamToRiffWebPBuffer = VP8BitStreamToRiffWebPBuffer;\n/**\n * RIFF データチャンクを作る\n */\n\nfunction createRIFFChunk(FourCC, chunk) {\n  var chunkSize = new exports.Buffer(4);\n  chunkSize.writeUInt32LE(chunk.byteLength, 0);\n  return concat([new exports.Buffer(FourCC.substr(0, 4), \"ascii\"), chunkSize, chunk, new exports.Buffer(chunk.byteLength % 2 === 0 ? 0 : 1) // padding\n  ]);\n}\n\nexports.createRIFFChunk = createRIFFChunk;\n/* Original Metadata\n\n m  0\tEBML\n u  1\t  EBMLVersion 1\n u  1\t  EBMLReadVersion 1\n u  1\t  EBMLMaxIDLength 4\n u  1\t  EBMLMaxSizeLength 8\n s  1\t  DocType webm\n u  1\t  DocTypeVersion 4\n u  1\t  DocTypeReadVersion 2\n m  0\tSegment\n m  1\t  Info                                segmentContentStartPos, all CueClusterPositions provided in info.cues will be relative to here and will need adjusted\n u  2\t    TimecodeScale 1000000\n 8  2\t    MuxingApp Chrome\n 8  2\t    WritingApp Chrome\n m  1\t  Tracks                              tracksStartPos\n m  2\t    TrackEntry\n u  3\t      TrackNumber 1\n u  3\t      TrackUID 31790271978391090\n u  3\t      TrackType 2\n s  3\t      CodecID A_OPUS\n b  3\t      CodecPrivate <Buffer 19>\n m  3\t      Audio\n f  4\t        SamplingFrequency 48000\n u  4\t        Channels 1\n m  2\t    TrackEntry\n u  3\t      TrackNumber 2\n u  3\t      TrackUID 24051277436254136\n u  3\t      TrackType 1\n s  3\t      CodecID V_VP8\n m  3\t      Video\n u  4\t        PixelWidth 1024\n u  4\t        PixelHeight 576\n m  1\t  Cluster                             clusterStartPos\n u  2\t    Timecode 0\n b  2\t    SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/\n\n/* Desired Metadata\n\n m\t0 EBML\n u\t1   EBMLVersion 1\n u\t1   EBMLReadVersion 1\n u\t1   EBMLMaxIDLength 4\n u\t1   EBMLMaxSizeLength 8\n s\t1   DocType webm\n u\t1   DocTypeVersion 4\n u\t1   DocTypeReadVersion 2\n m\t0 Segment\n m\t1   SeekHead                            -> This is SeekPosition 0, so all SeekPositions can be calculated as (bytePos - segmentContentStartPos), which is 44 in this case\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x15, 0x49, 0xA9, 0x66])  Info\n u\t3       SeekPosition                    -> infoStartPos =\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x16, 0x54, 0xAE, 0x6B])  Tracks\n u\t3       SeekPosition { tracksStartPos }\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x1C, 0x53, 0xBB, 0x6B])  Cues\n u\t3       SeekPosition { cuesStartPos }\n m\t1   Info\n f\t2     Duration 32480                    -> overwrite, or insert if it doesn't exist\n u\t2     TimecodeScale 1000000\n 8\t2     MuxingApp Chrome\n 8\t2     WritingApp Chrome\n m\t1   Tracks\n m\t2     TrackEntry\n u\t3       TrackNumber 1\n u\t3       TrackUID 31790271978391090\n u\t3       TrackType 2\n s\t3       CodecID A_OPUS\n b\t3       CodecPrivate <Buffer 19>\n m\t3       Audio\n f\t4         SamplingFrequency 48000\n u\t4         Channels 1\n m\t2     TrackEntry\n u\t3       TrackNumber 2\n u\t3       TrackUID 24051277436254136\n u\t3       TrackType 1\n s\t3       CodecID V_VP8\n m\t3       Video\n u\t4         PixelWidth 1024\n u\t4         PixelHeight 576\n m  1   Cues                                -> cuesStartPos\n m  2     CuePoint\n u  3       CueTime 0\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  2     CuePoint\n u  3       CueTime 600\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  1   Cluster\n u  2     Timecode 0\n b  2     SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/\n\n/**\n * convert the metadata from a streaming webm bytestream to a seekable file by inserting Duration, Seekhead and Cues\n * @param originalMetadata - orginal metadata (everything before the clusters start) from media recorder\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n */\n\nfunction makeMetadataSeekable(originalMetadata, duration, cuesInfo) {\n  // extract the header, we can reuse this as-is\n  var header = extractElement(\"EBML\", originalMetadata);\n  var headerSize = encodedSizeOfEbml(header); //console.error(\"Header size: \" + headerSize);\n  //printElementIds(header);\n  // After the header comes the Segment open tag, which in this implementation is always 12 bytes (4 byte id, 8 byte 'unknown length')\n  // After that the segment content starts. All SeekPositions and CueClusterPosition must be relative to segmentContentStartPos\n\n  var segmentContentStartPos = headerSize + 12; //console.error(\"segmentContentStartPos: \" + segmentContentStartPos);    \n  // find the original metadata size, and adjust it for header size and Segment start element so we can keep all positions relative to segmentContentStartPos\n\n  var originalMetadataSize = originalMetadata[originalMetadata.length - 1].dataEnd - segmentContentStartPos; //console.error(\"Original Metadata size: \" + originalMetadataSize);\n  //printElementIds(originalMetadata);\n  // extract the segment info, remove the potentially existing Duration element, and add our own one.\n\n  var info = extractElement(\"Info\", originalMetadata);\n  removeElement(\"Duration\", info);\n  info.splice(1, 0, {\n    name: \"Duration\",\n    type: \"f\",\n    data: createFloatBuffer(duration, 8)\n  });\n  var infoSize = encodedSizeOfEbml(info); //console.error(\"Info size: \" + infoSize);\n  //printElementIds(info);  \n  // extract the track info, we can re-use this as is\n\n  var tracks = extractElement(\"Tracks\", originalMetadata);\n  var tracksSize = encodedSizeOfEbml(tracks); //console.error(\"Tracks size: \" + tracksSize);\n  //printElementIds(tracks);  \n\n  var seekHeadSize = 47; // Initial best guess, but could be slightly larger if the Cues element is huge.\n\n  var seekHead = [];\n  var cuesSize = 5 + cuesInfo.length * 15; // very rough initial approximation, depends a lot on file size and number of CuePoints                   \n\n  var cues = [];\n  var lastSizeDifference = -1; // \n  // The size of SeekHead and Cues elements depends on how many bytes the offsets values can be encoded in.\n  // The actual offsets in CueClusterPosition depend on the final size of the SeekHead and Cues elements\n  // We need to iteratively converge to a stable solution.\n\n  var maxIterations = 10;\n\n  var _loop_1 = function (i) {\n    // SeekHead starts at 0\n    var infoStart = seekHeadSize; // Info comes directly after SeekHead\n\n    var tracksStart = infoStart + infoSize; // Tracks comes directly after Info\n\n    var cuesStart = tracksStart + tracksSize; // Cues starts directly after \n\n    var newMetadataSize = cuesStart + cuesSize; // total size of metadata  \n    // This is the offset all CueClusterPositions should be adjusted by due to the metadata size changing.\n\n    var sizeDifference = newMetadataSize - originalMetadataSize; // console.error(`infoStart: ${infoStart}, infoSize: ${infoSize}`);\n    // console.error(`tracksStart: ${tracksStart}, tracksSize: ${tracksSize}`);\n    // console.error(`cuesStart: ${cuesStart}, cuesSize: ${cuesSize}`);\n    // console.error(`originalMetadataSize: ${originalMetadataSize}, newMetadataSize: ${newMetadataSize}, sizeDifference: ${sizeDifference}`); \n    // create the SeekHead element\n\n    seekHead = [];\n    seekHead.push({\n      name: \"SeekHead\",\n      type: \"m\",\n      isEnd: false\n    });\n    seekHead.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: false\n    });\n    seekHead.push({\n      name: \"SeekID\",\n      type: \"b\",\n      data: new exports.Buffer([0x15, 0x49, 0xA9, 0x66])\n    }); // Info\n\n    seekHead.push({\n      name: \"SeekPosition\",\n      type: \"u\",\n      data: createUIntBuffer(infoStart)\n    });\n    seekHead.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: true\n    });\n    seekHead.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: false\n    });\n    seekHead.push({\n      name: \"SeekID\",\n      type: \"b\",\n      data: new exports.Buffer([0x16, 0x54, 0xAE, 0x6B])\n    }); // Tracks\n\n    seekHead.push({\n      name: \"SeekPosition\",\n      type: \"u\",\n      data: createUIntBuffer(tracksStart)\n    });\n    seekHead.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: true\n    });\n    seekHead.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: false\n    });\n    seekHead.push({\n      name: \"SeekID\",\n      type: \"b\",\n      data: new exports.Buffer([0x1C, 0x53, 0xBB, 0x6B])\n    }); // Cues\n\n    seekHead.push({\n      name: \"SeekPosition\",\n      type: \"u\",\n      data: createUIntBuffer(cuesStart)\n    });\n    seekHead.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: true\n    });\n    seekHead.push({\n      name: \"SeekHead\",\n      type: \"m\",\n      isEnd: true\n    });\n    seekHeadSize = encodedSizeOfEbml(seekHead); //console.error(\"SeekHead size: \" + seekHeadSize);\n    //printElementIds(seekHead);  \n    // create the Cues element\n\n    cues = [];\n    cues.push({\n      name: \"Cues\",\n      type: \"m\",\n      isEnd: false\n    });\n    cuesInfo.forEach(function (_a) {\n      var CueTrack = _a.CueTrack,\n          CueClusterPosition = _a.CueClusterPosition,\n          CueTime = _a.CueTime;\n      cues.push({\n        name: \"CuePoint\",\n        type: \"m\",\n        isEnd: false\n      });\n      cues.push({\n        name: \"CueTime\",\n        type: \"u\",\n        data: createUIntBuffer(CueTime)\n      });\n      cues.push({\n        name: \"CueTrackPositions\",\n        type: \"m\",\n        isEnd: false\n      });\n      cues.push({\n        name: \"CueTrack\",\n        type: \"u\",\n        data: createUIntBuffer(CueTrack)\n      }); //console.error(`CueClusterPosition: ${CueClusterPosition}, Corrected to: ${CueClusterPosition - segmentContentStartPos}  , offset by ${sizeDifference} to become ${(CueClusterPosition - segmentContentStartPos) + sizeDifference - segmentContentStartPos}`);\n      // EBMLReader returns CueClusterPosition with absolute byte offsets. The Cues section expects them as offsets from the first level 1 element of the Segment, so we need to adjust it.\n\n      CueClusterPosition -= segmentContentStartPos; // We also need to adjust to take into account the change in metadata size from when EBMLReader read the original metadata.\n\n      CueClusterPosition += sizeDifference;\n      cues.push({\n        name: \"CueClusterPosition\",\n        type: \"u\",\n        data: createUIntBuffer(CueClusterPosition)\n      });\n      cues.push({\n        name: \"CueTrackPositions\",\n        type: \"m\",\n        isEnd: true\n      });\n      cues.push({\n        name: \"CuePoint\",\n        type: \"m\",\n        isEnd: true\n      });\n    });\n    cues.push({\n      name: \"Cues\",\n      type: \"m\",\n      isEnd: true\n    });\n    cuesSize = encodedSizeOfEbml(cues); //console.error(\"Cues size: \" + cuesSize);   \n    //console.error(\"Cue count: \" + cuesInfo.length);\n    //printElementIds(cues);      \n    // If the new MetadataSize is not the same as the previous iteration, we need to run once more.\n\n    if (lastSizeDifference !== sizeDifference) {\n      lastSizeDifference = sizeDifference;\n\n      if (i === maxIterations - 1) {\n        throw new Error(\"Failed to converge to a stable metadata size\");\n      }\n    } else {\n      return \"break\";\n    }\n  };\n\n  for (var i = 0; i < maxIterations; i++) {\n    var state_1 = _loop_1(i);\n\n    if (state_1 === \"break\") break;\n  }\n\n  var finalMetadata = [].concat.apply([], [header, {\n    name: \"Segment\",\n    type: \"m\",\n    isEnd: false,\n    unknownSize: true\n  }, seekHead, info, tracks, cues]);\n  var result = new EBMLEncoder_1.default().encode(finalMetadata); //printElementIds(finalMetadata);\n  //console.error(`Final metadata buffer size: ${result.byteLength}`);\n  //console.error(`Final metadata buffer size without header and segment: ${result.byteLength-segmentContentStartPos}`);\n\n  return result;\n}\n\nexports.makeMetadataSeekable = makeMetadataSeekable;\n/**\n * print all element id names in a list\n\n * @param metadata - array of EBML elements to print\n *\nexport function printElementIds(metadata: EBML.EBMLElementBuffer[]) {\n\n  let result: EBML.EBMLElementBuffer[] = [];\n  let start: number = -1;\n\n  for (let i = 0; i < metadata.length; i++) {\n    console.error(\"\\t id: \" + metadata[i].name);\n  }\n}\n*/\n\n/**\n * remove all occurances of an EBML element from an array of elements\n * If it's a MasterElement you will also remove the content. (everything between start and end)\n * @param idName - name of the EBML Element to remove.\n * @param metadata - array of EBML elements to search\n */\n\nfunction removeElement(idName, metadata) {\n  var result = [];\n  var start = -1;\n\n  for (var i = 0; i < metadata.length; i++) {\n    var element = metadata[i];\n\n    if (element.name === idName) {\n      // if it's a Master element, extract the start and end element, and everything in between\n      if (element.type === \"m\") {\n        if (!element.isEnd) {\n          start = i;\n        } else {\n          // we've reached the end, extract the whole thing\n          if (start == -1) throw new Error(\"Detected \" + idName + \" closing element before finding the start\");\n          metadata.splice(start, i - start + 1);\n          return;\n        }\n      } else {\n        // not a Master element, so we've found what we're looking for.\n        metadata.splice(i, 1);\n        return;\n      }\n    }\n  }\n}\n\nexports.removeElement = removeElement;\n/**\n * extract the first occurance of an EBML tag from a flattened array of EBML data.\n * If it's a MasterElement you will also get the content. (everything between start and end)\n * @param idName - name of the EBML Element to extract.\n * @param metadata - array of EBML elements to search\n */\n\nfunction extractElement(idName, metadata) {\n  var result = [];\n  var start = -1;\n\n  for (var i = 0; i < metadata.length; i++) {\n    var element = metadata[i];\n\n    if (element.name === idName) {\n      // if it's a Master element, extract the start and end element, and everything in between\n      if (element.type === \"m\") {\n        if (!element.isEnd) {\n          start = i;\n        } else {\n          // we've reached the end, extract the whole thing\n          if (start == -1) throw new Error(\"Detected \" + idName + \" closing element before finding the start\");\n          result = metadata.slice(start, i + 1);\n          break;\n        }\n      } else {\n        // not a Master element, so we've found what we're looking for.\n        result.push(metadata[i]);\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n\nexports.extractElement = extractElement;\n/**\n * @deprecated\n * metadata に対して duration と seekhead を追加した metadata を返す\n * @param metadata - 変更前の webm における ファイル先頭から 最初の Cluster 要素までの 要素\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n * @deprecated @param clusterPtrs - 変更前の webm における SeekHead に追加する Cluster 要素 への start pointer\n * @deprecated @param cueInfos - please use cues.\n */\n\nfunction putRefinedMetaData(metadata, info) {\n  if (Array.isArray(info.cueInfos) && !Array.isArray(info.cues)) {\n    console.warn(\"putRefinedMetaData: info.cueInfos property is deprecated. please use info.cues\");\n    info.cues = info.cueInfos;\n  }\n\n  var ebml = [];\n  var payload = [];\n\n  for (var i_1 = 0; i_1 < metadata.length; i_1++) {\n    var elm = metadata[i_1];\n\n    if (elm.type === \"m\" && elm.name === \"Segment\") {\n      ebml = metadata.slice(0, i_1);\n      payload = metadata.slice(i_1);\n\n      if (elm.unknownSize) {\n        payload.shift(); // remove segment tag\n\n        break;\n      }\n\n      throw new Error(\"this metadata is not streaming webm file\");\n    }\n  } // *0    *4    *5  *36      *40   *48=segmentOffset              *185=originalPayloadOffsetEnd\n  // |     |     |   |        |     |                              |\n  // [EBML][size]....[Segment][size][Info][size][Duration][size]...[Cluster]\n  // |               |        |^inf |                              |\n  // |               +segmentSiz(12)+                              |\n  // +-ebmlSize(36)--+        |     +-payloadSize(137)-------------+offsetEndDiff+\n  //                 |        |     +-newPayloadSize(??)-------------------------+\n  //                 |        |     |                                            |\n  //                 [Segment][size][Info][size][Duration][size]....[size][value][Cluster]\n  //                           ^                                                 |\n  //                           |                                                 *??=newPayloadOffsetEnd\n  //                           inf\n\n\n  if (!(payload[payload.length - 1].dataEnd > 0)) {\n    throw new Error(\"metadata dataEnd has wrong number\");\n  }\n\n  var originalPayloadOffsetEnd = payload[payload.length - 1].dataEnd; // = first cluster ptr\n\n  var ebmlSize = ebml[ebml.length - 1].dataEnd; // = first segment ptr\n\n  var refinedEBMLSize = new EBMLEncoder_1.default().encode(ebml).byteLength;\n  var offsetDiff = refinedEBMLSize - ebmlSize;\n  var payloadSize = originalPayloadOffsetEnd - payload[0].tagStart;\n  var segmentSize = payload[0].tagStart - ebmlSize;\n  var segmentOffset = payload[0].tagStart;\n  var segmentTagBuf = new exports.Buffer([0x18, 0x53, 0x80, 0x67]); // Segment\n\n  var segmentSizeBuf = new exports.Buffer('01ffffffffffffff', 'hex'); // Segmentの最後の位置は無数の Cluster 依存なので。 writeVint(newPayloadSize).byteLength ではなく、 infinity.\n\n  var _segmentSize = segmentTagBuf.byteLength + segmentSizeBuf.byteLength; // == segmentSize\n\n\n  var newPayloadSize = payloadSize; // We need the size to be stable between two refinements in order for our offsets to be correct\n  // Bound the number of possible refinements so we can't go infinate if something goes wrong\n\n  var i;\n\n  for (i = 1; i < 20; i++) {\n    var newPayloadOffsetEnd = ebmlSize + _segmentSize + newPayloadSize;\n    var offsetEndDiff = newPayloadOffsetEnd - originalPayloadOffsetEnd;\n    var sizeDiff = offsetDiff + offsetEndDiff;\n    var refined = refineMetadata(payload, sizeDiff, info);\n    var newNewRefinedSize = new EBMLEncoder_1.default().encode(refined).byteLength; // 一旦 seekhead を作って自身のサイズを調べる\n\n    if (newNewRefinedSize === newPayloadSize) {\n      // Size is stable\n      return new EBMLEncoder_1.default().encode([].concat(ebml, [{\n        type: \"m\",\n        name: \"Segment\",\n        isEnd: false,\n        unknownSize: true\n      }], refined));\n    }\n\n    newPayloadSize = newNewRefinedSize;\n  }\n\n  throw new Error(\"unable to refine metadata, stable size could not be found in \" + i + \" iterations!\");\n}\n\nexports.putRefinedMetaData = putRefinedMetaData; // Given a list of EBMLElementBuffers, returns their encoded size in bytes\n\nfunction encodedSizeOfEbml(refinedMetaData) {\n  var encorder = new EBMLEncoder_1.default();\n  return refinedMetaData.reduce(function (lst, elm) {\n    return lst.concat(encorder.encode([elm]));\n  }, []).reduce(function (o, buf) {\n    return o + buf.byteLength;\n  }, 0);\n}\n\nfunction refineMetadata(mesetadata, sizeDiff, info) {\n  var duration = info.duration,\n      clusterPtrs = info.clusterPtrs,\n      cues = info.cues;\n\n  var _metadata = mesetadata.slice(0);\n\n  if (typeof duration === \"number\") {\n    // duration を追加する\n    var overwrited_1 = false;\n\n    _metadata.forEach(function (elm) {\n      if (elm.type === \"f\" && elm.name === \"Duration\") {\n        overwrited_1 = true;\n        elm.data = createFloatBuffer(duration, 8);\n      }\n    });\n\n    if (!overwrited_1) {\n      insertTag(_metadata, \"Info\", [{\n        name: \"Duration\",\n        type: \"f\",\n        data: createFloatBuffer(duration, 8)\n      }]);\n    }\n  }\n\n  if (Array.isArray(cues)) {\n    insertTag(_metadata, \"Cues\", create_cue(cues, sizeDiff));\n  }\n\n  var seekhead_children = [];\n\n  if (Array.isArray(clusterPtrs)) {\n    console.warn(\"append cluster pointers to seekhead is deprecated. please use cues\");\n    seekhead_children = create_seek_from_clusters(clusterPtrs, sizeDiff);\n  } // remove seek info\n\n  /*\n  _metadata = _metadata.filter((elm)=> !(\n    elm.name === \"Seek\" ||\n    elm.name === \"SeekID\" ||\n    elm.name === \"SeekPosition\") );\n  */\n  // working on progress\n  //seekhead_children = seekhead_children.concat(create_seekhead(_metadata));\n\n\n  insertTag(_metadata, \"SeekHead\", seekhead_children, true);\n  return _metadata;\n}\n\nfunction create_seekhead(metadata, sizeDiff) {\n  var seeks = [];\n  [\"Info\", \"Tracks\", \"Cues\"].forEach(function (tagName) {\n    var tagStarts = metadata.filter(function (elm) {\n      return elm.type === \"m\" && elm.name === tagName && elm.isEnd === false;\n    }).map(function (elm) {\n      return elm[\"tagStart\"];\n    });\n    var tagStart = tagStarts[0];\n\n    if (typeof tagStart !== \"number\") {\n      return;\n    }\n\n    seeks.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: false\n    });\n\n    switch (tagName) {\n      case \"Info\":\n        seeks.push({\n          name: \"SeekID\",\n          type: \"b\",\n          data: new exports.Buffer([0x15, 0x49, 0xA9, 0x66])\n        });\n        break;\n\n      case \"Tracks\":\n        seeks.push({\n          name: \"SeekID\",\n          type: \"b\",\n          data: new exports.Buffer([0x16, 0x54, 0xAE, 0x6B])\n        });\n        break;\n\n      case \"Cues\":\n        seeks.push({\n          name: \"SeekID\",\n          type: \"b\",\n          data: new exports.Buffer([0x1C, 0x53, 0xBB, 0x6B])\n        });\n        break;\n    }\n\n    seeks.push({\n      name: \"SeekPosition\",\n      type: \"u\",\n      data: createUIntBuffer(tagStart + sizeDiff)\n    });\n    seeks.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: true\n    });\n  });\n  return seeks;\n}\n\nfunction create_seek_from_clusters(clusterPtrs, sizeDiff) {\n  var seeks = [];\n  clusterPtrs.forEach(function (start) {\n    seeks.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: false\n    }); // [0x1F, 0x43, 0xB6, 0x75] で Cluster 意\n\n    seeks.push({\n      name: \"SeekID\",\n      type: \"b\",\n      data: new exports.Buffer([0x1F, 0x43, 0xB6, 0x75])\n    });\n    seeks.push({\n      name: \"SeekPosition\",\n      type: \"u\",\n      data: createUIntBuffer(start + sizeDiff)\n    });\n    seeks.push({\n      name: \"Seek\",\n      type: \"m\",\n      isEnd: true\n    });\n  });\n  return seeks;\n}\n\nfunction create_cue(cueInfos, sizeDiff) {\n  var cues = [];\n  cueInfos.forEach(function (_a) {\n    var CueTrack = _a.CueTrack,\n        CueClusterPosition = _a.CueClusterPosition,\n        CueTime = _a.CueTime;\n    cues.push({\n      name: \"CuePoint\",\n      type: \"m\",\n      isEnd: false\n    });\n    cues.push({\n      name: \"CueTime\",\n      type: \"u\",\n      data: createUIntBuffer(CueTime)\n    });\n    cues.push({\n      name: \"CueTrackPositions\",\n      type: \"m\",\n      isEnd: false\n    });\n    cues.push({\n      name: \"CueTrack\",\n      type: \"u\",\n      data: createUIntBuffer(CueTrack)\n    }); // video track\n\n    cues.push({\n      name: \"CueClusterPosition\",\n      type: \"u\",\n      data: createUIntBuffer(CueClusterPosition + sizeDiff)\n    });\n    cues.push({\n      name: \"CueTrackPositions\",\n      type: \"m\",\n      isEnd: true\n    });\n    cues.push({\n      name: \"CuePoint\",\n      type: \"m\",\n      isEnd: true\n    });\n  });\n  return cues;\n}\n\nfunction insertTag(_metadata, tagName, children, insertHead) {\n  if (insertHead === void 0) {\n    insertHead = false;\n  } // find the tagname from _metadata\n\n\n  var idx = -1;\n\n  for (var i = 0; i < _metadata.length; i++) {\n    var elm = _metadata[i];\n\n    if (elm.type === \"m\" && elm.name === tagName && elm.isEnd === false) {\n      idx = i;\n      break;\n    }\n  }\n\n  if (idx >= 0) {\n    // insert [<CuePoint />] to <Cues />\n    Array.prototype.splice.apply(_metadata, [idx + 1, 0].concat(children));\n  } else if (insertHead) {\n    [].concat([{\n      name: tagName,\n      type: \"m\",\n      isEnd: false\n    }], children, [{\n      name: tagName,\n      type: \"m\",\n      isEnd: true\n    }]).reverse().forEach(function (elm) {\n      _metadata.unshift(elm);\n    });\n  } else {\n    // metadata 末尾に <Cues /> を追加\n    // insert <Cues />\n    _metadata.push({\n      name: tagName,\n      type: \"m\",\n      isEnd: false\n    });\n\n    children.forEach(function (elm) {\n      _metadata.push(elm);\n    });\n\n    _metadata.push({\n      name: tagName,\n      type: \"m\",\n      isEnd: true\n    });\n  }\n} // alter Buffer.concat - https://github.com/feross/buffer/issues/154\n\n\nfunction concat(list) {\n  //return Buffer.concat.apply(Buffer, list);\n  var i = 0;\n  var length = 0;\n\n  for (; i < list.length; ++i) {\n    length += list[i].length;\n  }\n\n  var buffer = exports.Buffer.allocUnsafe(length);\n  var pos = 0;\n\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n\n  return buffer;\n}\n\nexports.concat = concat;\n\nfunction encodeValueToBuffer(elm) {\n  var data = new exports.Buffer(0);\n\n  if (elm.type === \"m\") {\n    return elm;\n  }\n\n  switch (elm.type) {\n    case \"u\":\n      data = createUIntBuffer(elm.value);\n      break;\n\n    case \"i\":\n      data = createIntBuffer(elm.value);\n      break;\n\n    case \"f\":\n      data = createFloatBuffer(elm.value);\n      break;\n\n    case \"s\":\n      data = new exports.Buffer(elm.value, 'ascii');\n      break;\n\n    case \"8\":\n      data = new exports.Buffer(elm.value, 'utf8');\n      break;\n\n    case \"b\":\n      data = elm.value;\n      break;\n\n    case \"d\":\n      data = new int64_buffer_1.Int64BE(elm.value.getTime().toString()).toBuffer();\n      break;\n  }\n\n  return Object.assign({}, elm, {\n    data: data\n  });\n}\n\nexports.encodeValueToBuffer = encodeValueToBuffer;\n\nfunction createUIntBuffer(value) {\n  // Big-endian, any size from 1 to 8\n  // but js number is float64, so max 6 bit octets\n  var bytes = 1;\n\n  for (; value >= Math.pow(2, 8 * bytes); bytes++) {}\n\n  if (bytes >= 7) {\n    console.warn(\"7bit or more bigger uint not supported.\");\n    return new int64_buffer_1.Uint64BE(value).toBuffer();\n  }\n\n  var data = new exports.Buffer(bytes);\n  data.writeUIntBE(value, 0, bytes);\n  return data;\n}\n\nexports.createUIntBuffer = createUIntBuffer;\n\nfunction createIntBuffer(value) {\n  // Big-endian, any size from 1 to 8 octets\n  // but js number is float64, so max 6 bit\n  var bytes = 1;\n\n  for (; value >= Math.pow(2, 8 * bytes); bytes++) {}\n\n  if (bytes >= 7) {\n    console.warn(\"7bit or more bigger uint not supported.\");\n    return new int64_buffer_1.Int64BE(value).toBuffer();\n  }\n\n  var data = new exports.Buffer(bytes);\n  data.writeIntBE(value, 0, bytes);\n  return data;\n}\n\nexports.createIntBuffer = createIntBuffer;\n\nfunction createFloatBuffer(value, bytes) {\n  if (bytes === void 0) {\n    bytes = 8;\n  } // Big-endian, defined for 4 and 8 octets (32, 64 bits)\n  // js number is float64 so 8 bytes.\n\n\n  if (bytes === 8) {\n    // 64bit\n    var data = new exports.Buffer(8);\n    data.writeDoubleBE(value, 0);\n    return data;\n  } else if (bytes === 4) {\n    // 32bit\n    var data = new exports.Buffer(4);\n    data.writeFloatBE(value, 0);\n    return data;\n  } else {\n    throw new Error(\"float type bits must 4bytes or 8bytes\");\n  }\n}\n\nexports.createFloatBuffer = createFloatBuffer;\n\nfunction convertEBMLDateToJSDate(int64str) {\n  if (int64str instanceof Date) {\n    return int64str;\n  }\n\n  return new Date(new Date(\"2001-01-01T00:00:00.000Z\").getTime() + Number(int64str) / 1000 / 1000);\n}\n\nexports.convertEBMLDateToJSDate = convertEBMLDateToJSDate;","map":{"version":3,"sources":["/Users/arnabdhar/Desktop/meetingbuddy/node_modules/ts-ebml/lib/tools.js"],"names":["Object","defineProperty","exports","value","int64_buffer_1","require","EBMLEncoder_1","_Buffer","_tools","_block","Buffer","readVint","writeVint","ebmlBlock","readBlock","buf","encodeTag","tagId","tagData","unknownSize","concat","length","WebPFrameFilter","elms","WebPBlockFilter","reduce","lst","elm","o","data","frames","frame","webpBuf","VP8BitStreamToRiffWebPBuffer","webp","Blob","type","name","hasWebP","some","startcode","slice","toString","VP8Chunk","createRIFFChunk","WebPChunk","FourCC","chunk","chunkSize","writeUInt32LE","byteLength","substr","makeMetadataSeekable","originalMetadata","duration","cuesInfo","header","extractElement","headerSize","encodedSizeOfEbml","segmentContentStartPos","originalMetadataSize","dataEnd","info","removeElement","splice","createFloatBuffer","infoSize","tracks","tracksSize","seekHeadSize","seekHead","cuesSize","cues","lastSizeDifference","maxIterations","_loop_1","i","infoStart","tracksStart","cuesStart","newMetadataSize","sizeDifference","push","isEnd","createUIntBuffer","forEach","_a","CueTrack","CueClusterPosition","CueTime","Error","state_1","finalMetadata","apply","result","default","encode","idName","metadata","start","element","putRefinedMetaData","Array","isArray","cueInfos","console","warn","ebml","payload","i_1","shift","originalPayloadOffsetEnd","ebmlSize","refinedEBMLSize","offsetDiff","payloadSize","tagStart","segmentSize","segmentOffset","segmentTagBuf","segmentSizeBuf","_segmentSize","newPayloadSize","newPayloadOffsetEnd","offsetEndDiff","sizeDiff","refined","refineMetadata","newNewRefinedSize","refinedMetaData","encorder","mesetadata","clusterPtrs","_metadata","overwrited_1","insertTag","create_cue","seekhead_children","create_seek_from_clusters","create_seekhead","seeks","tagName","tagStarts","filter","map","children","insertHead","idx","prototype","reverse","unshift","list","buffer","allocUnsafe","pos","copy","encodeValueToBuffer","createIntBuffer","Int64BE","getTime","toBuffer","assign","bytes","Math","pow","Uint64BE","writeUIntBE","writeIntBE","writeDoubleBE","writeFloatBE","convertEBMLDateToJSDate","int64str","Date","Number"],"mappings":"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M,CAAC,CACnB,IAAIlB,OAAO,CAACQ,MAAZ,CAAmB,MAAnB,EAA2B,OAA3B,CADmB,EAEnBiC,QAFmB,CAAD,CAAtB;AAIA,SAAOC,eAAe,CAAC,MAAD,EAASC,SAAT,CAAtB;AACH;;AACD3C,OAAO,CAAC+B,4BAAR,GAAuCA,4BAAvC;AACA;AACA;AACA;;AACA,SAASW,eAAT,CAAyBE,MAAzB,EAAiCC,KAAjC,EAAwC;AACpC,MAAIC,SAAS,GAAG,IAAI9C,OAAO,CAACQ,MAAZ,CAAmB,CAAnB,CAAhB;AACAsC,EAAAA,SAAS,CAACC,aAAV,CAAwBF,KAAK,CAACG,UAA9B,EAA0C,CAA1C;AACA,SAAO9B,MAAM,CAAC,CACV,IAAIlB,OAAO,CAACQ,MAAZ,CAAmBoC,MAAM,CAACK,MAAP,CAAc,CAAd,EAAiB,CAAjB,CAAnB,EAAwC,OAAxC,CADU,EAEVH,SAFU,EAGVD,KAHU,EAIV,IAAI7C,OAAO,CAACQ,MAAZ,CAAmBqC,KAAK,CAACG,UAAN,GAAmB,CAAnB,KAAyB,CAAzB,GAA6B,CAA7B,GAAiC,CAApD,CAJU,CAI6C;AAJ7C,GAAD,CAAb;AAMH;;AACDhD,OAAO,CAAC0C,eAAR,GAA0BA,eAA1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/// <reference types=\"node\"/>\nvar int64_buffer_1 = require(\"int64-buffer\");\nvar EBMLEncoder_1 = require(\"./EBMLEncoder\");\nvar _Buffer = require(\"buffer/\");\nvar _tools = require(\"ebml/lib/ebml/tools\");\nvar _block = require(\"ebml-block\");\nexports.Buffer = _Buffer.Buffer;\nexports.readVint = _tools.readVint;\nexports.writeVint = _tools.writeVint;\nexports.ebmlBlock = _block;\nfunction readBlock(buf) {\n    return exports.ebmlBlock(new exports.Buffer(buf));\n}\nexports.readBlock = readBlock;\n/**\n  * @param end - if end === false then length is unknown\n  */\nfunction encodeTag(tagId, tagData, unknownSize) {\n    if (unknownSize === void 0) { unknownSize = false; }\n    return concat([\n        tagId,\n        unknownSize ?\n            new exports.Buffer('01ffffffffffffff', 'hex') :\n            exports.writeVint(tagData.length),\n        tagData\n    ]);\n}\nexports.encodeTag = encodeTag;\n/**\n * @return - SimpleBlock to WebP Filter\n */\nfunction WebPFrameFilter(elms) {\n    return WebPBlockFilter(elms).reduce(function (lst, elm) {\n        var o = exports.ebmlBlock(elm.data);\n        return o.frames.reduce(function (lst, frame) {\n            // https://developers.Blob.com/speed/webp/docs/riff_container\n            var webpBuf = VP8BitStreamToRiffWebPBuffer(frame);\n            var webp = new Blob([webpBuf], { type: \"image/webp\" });\n            return lst.concat(webp);\n        }, lst);\n    }, []);\n}\nexports.WebPFrameFilter = WebPFrameFilter;\n/**\n * WebP ファイルにできる SimpleBlock の パスフィルタ\n */\nfunction WebPBlockFilter(elms) {\n    return elms.reduce(function (lst, elm) {\n        if (elm.type !== \"b\") {\n            return lst;\n        }\n        if (elm.name !== \"SimpleBlock\") {\n            return lst;\n        }\n        var o = exports.ebmlBlock(elm.data);\n        var hasWebP = o.frames.some(function (frame) {\n            // https://tools.ietf.org/html/rfc6386#section-19.1\n            var startcode = frame.slice(3, 6).toString(\"hex\");\n            return startcode === \"9d012a\";\n        });\n        if (!hasWebP) {\n            return lst;\n        }\n        return lst.concat(elm);\n    }, []);\n}\nexports.WebPBlockFilter = WebPBlockFilter;\n/**\n * @param frame - VP8 BitStream のうち startcode をもつ frame\n * @return - WebP ファイルの ArrayBuffer\n */\nfunction VP8BitStreamToRiffWebPBuffer(frame) {\n    var VP8Chunk = createRIFFChunk(\"VP8 \", frame);\n    var WebPChunk = concat([\n        new exports.Buffer(\"WEBP\", \"ascii\"),\n        VP8Chunk\n    ]);\n    return createRIFFChunk(\"RIFF\", WebPChunk);\n}\nexports.VP8BitStreamToRiffWebPBuffer = VP8BitStreamToRiffWebPBuffer;\n/**\n * RIFF データチャンクを作る\n */\nfunction createRIFFChunk(FourCC, chunk) {\n    var chunkSize = new exports.Buffer(4);\n    chunkSize.writeUInt32LE(chunk.byteLength, 0);\n    return concat([\n        new exports.Buffer(FourCC.substr(0, 4), \"ascii\"),\n        chunkSize,\n        chunk,\n        new exports.Buffer(chunk.byteLength % 2 === 0 ? 0 : 1) // padding\n    ]);\n}\nexports.createRIFFChunk = createRIFFChunk;\n/* Original Metadata\n\n m  0\tEBML\n u  1\t  EBMLVersion 1\n u  1\t  EBMLReadVersion 1\n u  1\t  EBMLMaxIDLength 4\n u  1\t  EBMLMaxSizeLength 8\n s  1\t  DocType webm\n u  1\t  DocTypeVersion 4\n u  1\t  DocTypeReadVersion 2\n m  0\tSegment\n m  1\t  Info                                segmentContentStartPos, all CueClusterPositions provided in info.cues will be relative to here and will need adjusted\n u  2\t    TimecodeScale 1000000\n 8  2\t    MuxingApp Chrome\n 8  2\t    WritingApp Chrome\n m  1\t  Tracks                              tracksStartPos\n m  2\t    TrackEntry\n u  3\t      TrackNumber 1\n u  3\t      TrackUID 31790271978391090\n u  3\t      TrackType 2\n s  3\t      CodecID A_OPUS\n b  3\t      CodecPrivate <Buffer 19>\n m  3\t      Audio\n f  4\t        SamplingFrequency 48000\n u  4\t        Channels 1\n m  2\t    TrackEntry\n u  3\t      TrackNumber 2\n u  3\t      TrackUID 24051277436254136\n u  3\t      TrackType 1\n s  3\t      CodecID V_VP8\n m  3\t      Video\n u  4\t        PixelWidth 1024\n u  4\t        PixelHeight 576\n m  1\t  Cluster                             clusterStartPos\n u  2\t    Timecode 0\n b  2\t    SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/\n/* Desired Metadata\n\n m\t0 EBML\n u\t1   EBMLVersion 1\n u\t1   EBMLReadVersion 1\n u\t1   EBMLMaxIDLength 4\n u\t1   EBMLMaxSizeLength 8\n s\t1   DocType webm\n u\t1   DocTypeVersion 4\n u\t1   DocTypeReadVersion 2\n m\t0 Segment\n m\t1   SeekHead                            -> This is SeekPosition 0, so all SeekPositions can be calculated as (bytePos - segmentContentStartPos), which is 44 in this case\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x15, 0x49, 0xA9, 0x66])  Info\n u\t3       SeekPosition                    -> infoStartPos =\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x16, 0x54, 0xAE, 0x6B])  Tracks\n u\t3       SeekPosition { tracksStartPos }\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x1C, 0x53, 0xBB, 0x6B])  Cues\n u\t3       SeekPosition { cuesStartPos }\n m\t1   Info\n f\t2     Duration 32480                    -> overwrite, or insert if it doesn't exist\n u\t2     TimecodeScale 1000000\n 8\t2     MuxingApp Chrome\n 8\t2     WritingApp Chrome\n m\t1   Tracks\n m\t2     TrackEntry\n u\t3       TrackNumber 1\n u\t3       TrackUID 31790271978391090\n u\t3       TrackType 2\n s\t3       CodecID A_OPUS\n b\t3       CodecPrivate <Buffer 19>\n m\t3       Audio\n f\t4         SamplingFrequency 48000\n u\t4         Channels 1\n m\t2     TrackEntry\n u\t3       TrackNumber 2\n u\t3       TrackUID 24051277436254136\n u\t3       TrackType 1\n s\t3       CodecID V_VP8\n m\t3       Video\n u\t4         PixelWidth 1024\n u\t4         PixelHeight 576\n m  1   Cues                                -> cuesStartPos\n m  2     CuePoint\n u  3       CueTime 0\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  2     CuePoint\n u  3       CueTime 600\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  1   Cluster\n u  2     Timecode 0\n b  2     SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/\n/**\n * convert the metadata from a streaming webm bytestream to a seekable file by inserting Duration, Seekhead and Cues\n * @param originalMetadata - orginal metadata (everything before the clusters start) from media recorder\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n */\nfunction makeMetadataSeekable(originalMetadata, duration, cuesInfo) {\n    // extract the header, we can reuse this as-is\n    var header = extractElement(\"EBML\", originalMetadata);\n    var headerSize = encodedSizeOfEbml(header);\n    //console.error(\"Header size: \" + headerSize);\n    //printElementIds(header);\n    // After the header comes the Segment open tag, which in this implementation is always 12 bytes (4 byte id, 8 byte 'unknown length')\n    // After that the segment content starts. All SeekPositions and CueClusterPosition must be relative to segmentContentStartPos\n    var segmentContentStartPos = headerSize + 12;\n    //console.error(\"segmentContentStartPos: \" + segmentContentStartPos);    \n    // find the original metadata size, and adjust it for header size and Segment start element so we can keep all positions relative to segmentContentStartPos\n    var originalMetadataSize = originalMetadata[originalMetadata.length - 1].dataEnd - segmentContentStartPos;\n    //console.error(\"Original Metadata size: \" + originalMetadataSize);\n    //printElementIds(originalMetadata);\n    // extract the segment info, remove the potentially existing Duration element, and add our own one.\n    var info = extractElement(\"Info\", originalMetadata);\n    removeElement(\"Duration\", info);\n    info.splice(1, 0, { name: \"Duration\", type: \"f\", data: createFloatBuffer(duration, 8) });\n    var infoSize = encodedSizeOfEbml(info);\n    //console.error(\"Info size: \" + infoSize);\n    //printElementIds(info);  \n    // extract the track info, we can re-use this as is\n    var tracks = extractElement(\"Tracks\", originalMetadata);\n    var tracksSize = encodedSizeOfEbml(tracks);\n    //console.error(\"Tracks size: \" + tracksSize);\n    //printElementIds(tracks);  \n    var seekHeadSize = 47; // Initial best guess, but could be slightly larger if the Cues element is huge.\n    var seekHead = [];\n    var cuesSize = 5 + cuesInfo.length * 15; // very rough initial approximation, depends a lot on file size and number of CuePoints                   \n    var cues = [];\n    var lastSizeDifference = -1; // \n    // The size of SeekHead and Cues elements depends on how many bytes the offsets values can be encoded in.\n    // The actual offsets in CueClusterPosition depend on the final size of the SeekHead and Cues elements\n    // We need to iteratively converge to a stable solution.\n    var maxIterations = 10;\n    var _loop_1 = function (i) {\n        // SeekHead starts at 0\n        var infoStart = seekHeadSize; // Info comes directly after SeekHead\n        var tracksStart = infoStart + infoSize; // Tracks comes directly after Info\n        var cuesStart = tracksStart + tracksSize; // Cues starts directly after \n        var newMetadataSize = cuesStart + cuesSize; // total size of metadata  \n        // This is the offset all CueClusterPositions should be adjusted by due to the metadata size changing.\n        var sizeDifference = newMetadataSize - originalMetadataSize;\n        // console.error(`infoStart: ${infoStart}, infoSize: ${infoSize}`);\n        // console.error(`tracksStart: ${tracksStart}, tracksSize: ${tracksSize}`);\n        // console.error(`cuesStart: ${cuesStart}, cuesSize: ${cuesSize}`);\n        // console.error(`originalMetadataSize: ${originalMetadataSize}, newMetadataSize: ${newMetadataSize}, sizeDifference: ${sizeDifference}`); \n        // create the SeekHead element\n        seekHead = [];\n        seekHead.push({ name: \"SeekHead\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x15, 0x49, 0xA9, 0x66]) }); // Info\n        seekHead.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(infoStart) });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: true });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x16, 0x54, 0xAE, 0x6B]) }); // Tracks\n        seekHead.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(tracksStart) });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: true });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        seekHead.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x1C, 0x53, 0xBB, 0x6B]) }); // Cues\n        seekHead.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(cuesStart) });\n        seekHead.push({ name: \"Seek\", type: \"m\", isEnd: true });\n        seekHead.push({ name: \"SeekHead\", type: \"m\", isEnd: true });\n        seekHeadSize = encodedSizeOfEbml(seekHead);\n        //console.error(\"SeekHead size: \" + seekHeadSize);\n        //printElementIds(seekHead);  \n        // create the Cues element\n        cues = [];\n        cues.push({ name: \"Cues\", type: \"m\", isEnd: false });\n        cuesInfo.forEach(function (_a) {\n            var CueTrack = _a.CueTrack, CueClusterPosition = _a.CueClusterPosition, CueTime = _a.CueTime;\n            cues.push({ name: \"CuePoint\", type: \"m\", isEnd: false });\n            cues.push({ name: \"CueTime\", type: \"u\", data: createUIntBuffer(CueTime) });\n            cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: false });\n            cues.push({ name: \"CueTrack\", type: \"u\", data: createUIntBuffer(CueTrack) });\n            //console.error(`CueClusterPosition: ${CueClusterPosition}, Corrected to: ${CueClusterPosition - segmentContentStartPos}  , offset by ${sizeDifference} to become ${(CueClusterPosition - segmentContentStartPos) + sizeDifference - segmentContentStartPos}`);\n            // EBMLReader returns CueClusterPosition with absolute byte offsets. The Cues section expects them as offsets from the first level 1 element of the Segment, so we need to adjust it.\n            CueClusterPosition -= segmentContentStartPos;\n            // We also need to adjust to take into account the change in metadata size from when EBMLReader read the original metadata.\n            CueClusterPosition += sizeDifference;\n            cues.push({ name: \"CueClusterPosition\", type: \"u\", data: createUIntBuffer(CueClusterPosition) });\n            cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: true });\n            cues.push({ name: \"CuePoint\", type: \"m\", isEnd: true });\n        });\n        cues.push({ name: \"Cues\", type: \"m\", isEnd: true });\n        cuesSize = encodedSizeOfEbml(cues);\n        //console.error(\"Cues size: \" + cuesSize);   \n        //console.error(\"Cue count: \" + cuesInfo.length);\n        //printElementIds(cues);      \n        // If the new MetadataSize is not the same as the previous iteration, we need to run once more.\n        if (lastSizeDifference !== sizeDifference) {\n            lastSizeDifference = sizeDifference;\n            if (i === maxIterations - 1) {\n                throw new Error(\"Failed to converge to a stable metadata size\");\n            }\n        }\n        else {\n            return \"break\";\n        }\n    };\n    for (var i = 0; i < maxIterations; i++) {\n        var state_1 = _loop_1(i);\n        if (state_1 === \"break\")\n            break;\n    }\n    var finalMetadata = [].concat.apply([], [\n        header,\n        { name: \"Segment\", type: \"m\", isEnd: false, unknownSize: true },\n        seekHead,\n        info,\n        tracks,\n        cues\n    ]);\n    var result = new EBMLEncoder_1.default().encode(finalMetadata);\n    //printElementIds(finalMetadata);\n    //console.error(`Final metadata buffer size: ${result.byteLength}`);\n    //console.error(`Final metadata buffer size without header and segment: ${result.byteLength-segmentContentStartPos}`);\n    return result;\n}\nexports.makeMetadataSeekable = makeMetadataSeekable;\n/**\n * print all element id names in a list\n\n * @param metadata - array of EBML elements to print\n *\nexport function printElementIds(metadata: EBML.EBMLElementBuffer[]) {\n\n  let result: EBML.EBMLElementBuffer[] = [];\n  let start: number = -1;\n\n  for (let i = 0; i < metadata.length; i++) {\n    console.error(\"\\t id: \" + metadata[i].name);\n  }\n}\n*/\n/**\n * remove all occurances of an EBML element from an array of elements\n * If it's a MasterElement you will also remove the content. (everything between start and end)\n * @param idName - name of the EBML Element to remove.\n * @param metadata - array of EBML elements to search\n */\nfunction removeElement(idName, metadata) {\n    var result = [];\n    var start = -1;\n    for (var i = 0; i < metadata.length; i++) {\n        var element = metadata[i];\n        if (element.name === idName) {\n            // if it's a Master element, extract the start and end element, and everything in between\n            if (element.type === \"m\") {\n                if (!element.isEnd) {\n                    start = i;\n                }\n                else {\n                    // we've reached the end, extract the whole thing\n                    if (start == -1)\n                        throw new Error(\"Detected \" + idName + \" closing element before finding the start\");\n                    metadata.splice(start, i - start + 1);\n                    return;\n                }\n            }\n            else {\n                // not a Master element, so we've found what we're looking for.\n                metadata.splice(i, 1);\n                return;\n            }\n        }\n    }\n}\nexports.removeElement = removeElement;\n/**\n * extract the first occurance of an EBML tag from a flattened array of EBML data.\n * If it's a MasterElement you will also get the content. (everything between start and end)\n * @param idName - name of the EBML Element to extract.\n * @param metadata - array of EBML elements to search\n */\nfunction extractElement(idName, metadata) {\n    var result = [];\n    var start = -1;\n    for (var i = 0; i < metadata.length; i++) {\n        var element = metadata[i];\n        if (element.name === idName) {\n            // if it's a Master element, extract the start and end element, and everything in between\n            if (element.type === \"m\") {\n                if (!element.isEnd) {\n                    start = i;\n                }\n                else {\n                    // we've reached the end, extract the whole thing\n                    if (start == -1)\n                        throw new Error(\"Detected \" + idName + \" closing element before finding the start\");\n                    result = metadata.slice(start, i + 1);\n                    break;\n                }\n            }\n            else {\n                // not a Master element, so we've found what we're looking for.\n                result.push(metadata[i]);\n                break;\n            }\n        }\n    }\n    return result;\n}\nexports.extractElement = extractElement;\n/**\n * @deprecated\n * metadata に対して duration と seekhead を追加した metadata を返す\n * @param metadata - 変更前の webm における ファイル先頭から 最初の Cluster 要素までの 要素\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n * @deprecated @param clusterPtrs - 変更前の webm における SeekHead に追加する Cluster 要素 への start pointer\n * @deprecated @param cueInfos - please use cues.\n */\nfunction putRefinedMetaData(metadata, info) {\n    if (Array.isArray(info.cueInfos) && !Array.isArray(info.cues)) {\n        console.warn(\"putRefinedMetaData: info.cueInfos property is deprecated. please use info.cues\");\n        info.cues = info.cueInfos;\n    }\n    var ebml = [];\n    var payload = [];\n    for (var i_1 = 0; i_1 < metadata.length; i_1++) {\n        var elm = metadata[i_1];\n        if (elm.type === \"m\" && elm.name === \"Segment\") {\n            ebml = metadata.slice(0, i_1);\n            payload = metadata.slice(i_1);\n            if (elm.unknownSize) {\n                payload.shift(); // remove segment tag\n                break;\n            }\n            throw new Error(\"this metadata is not streaming webm file\");\n        }\n    }\n    // *0    *4    *5  *36      *40   *48=segmentOffset              *185=originalPayloadOffsetEnd\n    // |     |     |   |        |     |                              |\n    // [EBML][size]....[Segment][size][Info][size][Duration][size]...[Cluster]\n    // |               |        |^inf |                              |\n    // |               +segmentSiz(12)+                              |\n    // +-ebmlSize(36)--+        |     +-payloadSize(137)-------------+offsetEndDiff+\n    //                 |        |     +-newPayloadSize(??)-------------------------+\n    //                 |        |     |                                            |\n    //                 [Segment][size][Info][size][Duration][size]....[size][value][Cluster]\n    //                           ^                                                 |\n    //                           |                                                 *??=newPayloadOffsetEnd\n    //                           inf\n    if (!(payload[payload.length - 1].dataEnd > 0)) {\n        throw new Error(\"metadata dataEnd has wrong number\");\n    }\n    var originalPayloadOffsetEnd = payload[payload.length - 1].dataEnd; // = first cluster ptr\n    var ebmlSize = ebml[ebml.length - 1].dataEnd; // = first segment ptr\n    var refinedEBMLSize = new EBMLEncoder_1.default().encode(ebml).byteLength;\n    var offsetDiff = refinedEBMLSize - ebmlSize;\n    var payloadSize = originalPayloadOffsetEnd - payload[0].tagStart;\n    var segmentSize = payload[0].tagStart - ebmlSize;\n    var segmentOffset = payload[0].tagStart;\n    var segmentTagBuf = new exports.Buffer([0x18, 0x53, 0x80, 0x67]); // Segment\n    var segmentSizeBuf = new exports.Buffer('01ffffffffffffff', 'hex'); // Segmentの最後の位置は無数の Cluster 依存なので。 writeVint(newPayloadSize).byteLength ではなく、 infinity.\n    var _segmentSize = segmentTagBuf.byteLength + segmentSizeBuf.byteLength; // == segmentSize\n    var newPayloadSize = payloadSize;\n    // We need the size to be stable between two refinements in order for our offsets to be correct\n    // Bound the number of possible refinements so we can't go infinate if something goes wrong\n    var i;\n    for (i = 1; i < 20; i++) {\n        var newPayloadOffsetEnd = ebmlSize + _segmentSize + newPayloadSize;\n        var offsetEndDiff = newPayloadOffsetEnd - originalPayloadOffsetEnd;\n        var sizeDiff = offsetDiff + offsetEndDiff;\n        var refined = refineMetadata(payload, sizeDiff, info);\n        var newNewRefinedSize = new EBMLEncoder_1.default().encode(refined).byteLength; // 一旦 seekhead を作って自身のサイズを調べる\n        if (newNewRefinedSize === newPayloadSize) {\n            // Size is stable\n            return new EBMLEncoder_1.default().encode([].concat(ebml, [{ type: \"m\", name: \"Segment\", isEnd: false, unknownSize: true }], refined));\n        }\n        newPayloadSize = newNewRefinedSize;\n    }\n    throw new Error(\"unable to refine metadata, stable size could not be found in \" + i + \" iterations!\");\n}\nexports.putRefinedMetaData = putRefinedMetaData;\n// Given a list of EBMLElementBuffers, returns their encoded size in bytes\nfunction encodedSizeOfEbml(refinedMetaData) {\n    var encorder = new EBMLEncoder_1.default();\n    return refinedMetaData.reduce(function (lst, elm) { return lst.concat(encorder.encode([elm])); }, []).reduce(function (o, buf) { return o + buf.byteLength; }, 0);\n}\nfunction refineMetadata(mesetadata, sizeDiff, info) {\n    var duration = info.duration, clusterPtrs = info.clusterPtrs, cues = info.cues;\n    var _metadata = mesetadata.slice(0);\n    if (typeof duration === \"number\") {\n        // duration を追加する\n        var overwrited_1 = false;\n        _metadata.forEach(function (elm) {\n            if (elm.type === \"f\" && elm.name === \"Duration\") {\n                overwrited_1 = true;\n                elm.data = createFloatBuffer(duration, 8);\n            }\n        });\n        if (!overwrited_1) {\n            insertTag(_metadata, \"Info\", [{ name: \"Duration\", type: \"f\", data: createFloatBuffer(duration, 8) }]);\n        }\n    }\n    if (Array.isArray(cues)) {\n        insertTag(_metadata, \"Cues\", create_cue(cues, sizeDiff));\n    }\n    var seekhead_children = [];\n    if (Array.isArray(clusterPtrs)) {\n        console.warn(\"append cluster pointers to seekhead is deprecated. please use cues\");\n        seekhead_children = create_seek_from_clusters(clusterPtrs, sizeDiff);\n    }\n    // remove seek info\n    /*\n    _metadata = _metadata.filter((elm)=> !(\n      elm.name === \"Seek\" ||\n      elm.name === \"SeekID\" ||\n      elm.name === \"SeekPosition\") );\n    */\n    // working on progress\n    //seekhead_children = seekhead_children.concat(create_seekhead(_metadata));\n    insertTag(_metadata, \"SeekHead\", seekhead_children, true);\n    return _metadata;\n}\nfunction create_seekhead(metadata, sizeDiff) {\n    var seeks = [];\n    [\"Info\", \"Tracks\", \"Cues\"].forEach(function (tagName) {\n        var tagStarts = metadata.filter(function (elm) { return elm.type === \"m\" && elm.name === tagName && elm.isEnd === false; }).map(function (elm) { return elm[\"tagStart\"]; });\n        var tagStart = tagStarts[0];\n        if (typeof tagStart !== \"number\") {\n            return;\n        }\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        switch (tagName) {\n            case \"Info\":\n                seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x15, 0x49, 0xA9, 0x66]) });\n                break;\n            case \"Tracks\":\n                seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x16, 0x54, 0xAE, 0x6B]) });\n                break;\n            case \"Cues\":\n                seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x1C, 0x53, 0xBB, 0x6B]) });\n                break;\n        }\n        seeks.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(tagStart + sizeDiff) });\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: true });\n    });\n    return seeks;\n}\nfunction create_seek_from_clusters(clusterPtrs, sizeDiff) {\n    var seeks = [];\n    clusterPtrs.forEach(function (start) {\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: false });\n        // [0x1F, 0x43, 0xB6, 0x75] で Cluster 意\n        seeks.push({ name: \"SeekID\", type: \"b\", data: new exports.Buffer([0x1F, 0x43, 0xB6, 0x75]) });\n        seeks.push({ name: \"SeekPosition\", type: \"u\", data: createUIntBuffer(start + sizeDiff) });\n        seeks.push({ name: \"Seek\", type: \"m\", isEnd: true });\n    });\n    return seeks;\n}\nfunction create_cue(cueInfos, sizeDiff) {\n    var cues = [];\n    cueInfos.forEach(function (_a) {\n        var CueTrack = _a.CueTrack, CueClusterPosition = _a.CueClusterPosition, CueTime = _a.CueTime;\n        cues.push({ name: \"CuePoint\", type: \"m\", isEnd: false });\n        cues.push({ name: \"CueTime\", type: \"u\", data: createUIntBuffer(CueTime) });\n        cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: false });\n        cues.push({ name: \"CueTrack\", type: \"u\", data: createUIntBuffer(CueTrack) }); // video track\n        cues.push({ name: \"CueClusterPosition\", type: \"u\", data: createUIntBuffer(CueClusterPosition + sizeDiff) });\n        cues.push({ name: \"CueTrackPositions\", type: \"m\", isEnd: true });\n        cues.push({ name: \"CuePoint\", type: \"m\", isEnd: true });\n    });\n    return cues;\n}\nfunction insertTag(_metadata, tagName, children, insertHead) {\n    if (insertHead === void 0) { insertHead = false; }\n    // find the tagname from _metadata\n    var idx = -1;\n    for (var i = 0; i < _metadata.length; i++) {\n        var elm = _metadata[i];\n        if (elm.type === \"m\" && elm.name === tagName && elm.isEnd === false) {\n            idx = i;\n            break;\n        }\n    }\n    if (idx >= 0) {\n        // insert [<CuePoint />] to <Cues />\n        Array.prototype.splice.apply(_metadata, [idx + 1, 0].concat(children));\n    }\n    else if (insertHead) {\n        [].concat([{ name: tagName, type: \"m\", isEnd: false }], children, [{ name: tagName, type: \"m\", isEnd: true }]).reverse().forEach(function (elm) { _metadata.unshift(elm); });\n    }\n    else {\n        // metadata 末尾に <Cues /> を追加\n        // insert <Cues />\n        _metadata.push({ name: tagName, type: \"m\", isEnd: false });\n        children.forEach(function (elm) { _metadata.push(elm); });\n        _metadata.push({ name: tagName, type: \"m\", isEnd: true });\n    }\n}\n// alter Buffer.concat - https://github.com/feross/buffer/issues/154\nfunction concat(list) {\n    //return Buffer.concat.apply(Buffer, list);\n    var i = 0;\n    var length = 0;\n    for (; i < list.length; ++i) {\n        length += list[i].length;\n    }\n    var buffer = exports.Buffer.allocUnsafe(length);\n    var pos = 0;\n    for (i = 0; i < list.length; ++i) {\n        var buf = list[i];\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n}\nexports.concat = concat;\nfunction encodeValueToBuffer(elm) {\n    var data = new exports.Buffer(0);\n    if (elm.type === \"m\") {\n        return elm;\n    }\n    switch (elm.type) {\n        case \"u\":\n            data = createUIntBuffer(elm.value);\n            break;\n        case \"i\":\n            data = createIntBuffer(elm.value);\n            break;\n        case \"f\":\n            data = createFloatBuffer(elm.value);\n            break;\n        case \"s\":\n            data = new exports.Buffer(elm.value, 'ascii');\n            break;\n        case \"8\":\n            data = new exports.Buffer(elm.value, 'utf8');\n            break;\n        case \"b\":\n            data = elm.value;\n            break;\n        case \"d\":\n            data = new int64_buffer_1.Int64BE(elm.value.getTime().toString()).toBuffer();\n            break;\n    }\n    return Object.assign({}, elm, { data: data });\n}\nexports.encodeValueToBuffer = encodeValueToBuffer;\nfunction createUIntBuffer(value) {\n    // Big-endian, any size from 1 to 8\n    // but js number is float64, so max 6 bit octets\n    var bytes = 1;\n    for (; value >= Math.pow(2, 8 * bytes); bytes++) { }\n    if (bytes >= 7) {\n        console.warn(\"7bit or more bigger uint not supported.\");\n        return new int64_buffer_1.Uint64BE(value).toBuffer();\n    }\n    var data = new exports.Buffer(bytes);\n    data.writeUIntBE(value, 0, bytes);\n    return data;\n}\nexports.createUIntBuffer = createUIntBuffer;\nfunction createIntBuffer(value) {\n    // Big-endian, any size from 1 to 8 octets\n    // but js number is float64, so max 6 bit\n    var bytes = 1;\n    for (; value >= Math.pow(2, 8 * bytes); bytes++) { }\n    if (bytes >= 7) {\n        console.warn(\"7bit or more bigger uint not supported.\");\n        return new int64_buffer_1.Int64BE(value).toBuffer();\n    }\n    var data = new exports.Buffer(bytes);\n    data.writeIntBE(value, 0, bytes);\n    return data;\n}\nexports.createIntBuffer = createIntBuffer;\nfunction createFloatBuffer(value, bytes) {\n    if (bytes === void 0) { bytes = 8; }\n    // Big-endian, defined for 4 and 8 octets (32, 64 bits)\n    // js number is float64 so 8 bytes.\n    if (bytes === 8) {\n        // 64bit\n        var data = new exports.Buffer(8);\n        data.writeDoubleBE(value, 0);\n        return data;\n    }\n    else if (bytes === 4) {\n        // 32bit\n        var data = new exports.Buffer(4);\n        data.writeFloatBE(value, 0);\n        return data;\n    }\n    else {\n        throw new Error(\"float type bits must 4bytes or 8bytes\");\n    }\n}\nexports.createFloatBuffer = createFloatBuffer;\nfunction convertEBMLDateToJSDate(int64str) {\n    if (int64str instanceof Date) {\n        return int64str;\n    }\n    return new Date(new Date(\"2001-01-01T00:00:00.000Z\").getTime() + (Number(int64str) / 1000 / 1000));\n}\nexports.convertEBMLDateToJSDate = convertEBMLDateToJSDate;\n"]},"metadata":{},"sourceType":"script"}