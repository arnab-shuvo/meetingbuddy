{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar tools = require(\"./tools\");\n/**\n * This is an informal code for reference.\n * EBMLReader is a class for getting information to enable seeking Webm recorded by MediaRecorder.\n * So please do not use for regular WebM files.\n */\n\n\nvar EBMLReader = function (_super) {\n  __extends(EBMLReader, _super);\n\n  function EBMLReader() {\n    var _this = _super.call(this) || this;\n\n    _this.logGroup = \"\";\n    _this.hasLoggingStarted = false;\n    _this.metadataloaded = false;\n    _this.chunks = [];\n    _this.stack = [];\n    _this.segmentOffset = 0;\n    _this.last2SimpleBlockVideoTrackTimecode = [0, 0];\n    _this.last2SimpleBlockAudioTrackTimecode = [0, 0];\n    _this.lastClusterTimecode = 0;\n    _this.lastClusterPosition = 0;\n    _this.timecodeScale = 1000000; // webm default TimecodeScale is 1ms\n\n    _this.metadataSize = 0;\n    _this.metadatas = [];\n    _this.cues = [];\n    _this.firstVideoBlockRead = false;\n    _this.firstAudioBlockRead = false;\n    _this.currentTrack = {\n      TrackNumber: -1,\n      TrackType: -1,\n      DefaultDuration: null,\n      CodecDelay: null\n    };\n    _this.trackTypes = [];\n    _this.trackDefaultDuration = [];\n    _this.trackCodecDelay = [];\n    _this.trackInfo = {\n      type: \"nothing\"\n    };\n    _this.ended = false;\n    _this.logging = false;\n    _this.use_duration_every_simpleblock = false;\n    _this.use_webp = false;\n    _this.use_segment_info = true;\n    _this.drop_default_duration = true;\n    return _this;\n  }\n  /**\n   * emit final state.\n   */\n\n\n  EBMLReader.prototype.stop = function () {\n    this.ended = true;\n    this.emit_segment_info(); // clean up any unclosed Master Elements at the end of the stream.\n\n    while (this.stack.length) {\n      this.stack.pop();\n\n      if (this.logging) {\n        console.groupEnd();\n      }\n    } // close main group if set, logging is enabled, and has actually logged anything.\n\n\n    if (this.logging && this.hasLoggingStarted && this.logGroup) {\n      console.groupEnd();\n    }\n  };\n  /**\n   * emit chunk info\n   */\n\n\n  EBMLReader.prototype.emit_segment_info = function () {\n    var data = this.chunks;\n    this.chunks = [];\n\n    if (!this.metadataloaded) {\n      this.metadataloaded = true;\n      this.metadatas = data;\n      var videoTrackNum = this.trackTypes.indexOf(1); // find first video track\n\n      var audioTrackNum = this.trackTypes.indexOf(2); // find first audio track\n\n      this.trackInfo = videoTrackNum >= 0 && audioTrackNum >= 0 ? {\n        type: \"both\",\n        trackNumber: videoTrackNum\n      } : videoTrackNum >= 0 ? {\n        type: \"video\",\n        trackNumber: videoTrackNum\n      } : audioTrackNum >= 0 ? {\n        type: \"audio\",\n        trackNumber: audioTrackNum\n      } : {\n        type: \"nothing\"\n      };\n\n      if (!this.use_segment_info) {\n        return;\n      }\n\n      this.emit(\"metadata\", {\n        data: data,\n        metadataSize: this.metadataSize\n      });\n    } else {\n      if (!this.use_segment_info) {\n        return;\n      }\n\n      var timecode = this.lastClusterTimecode;\n      var duration = this.duration;\n      var timecodeScale = this.timecodeScale;\n      this.emit(\"cluster\", {\n        timecode: timecode,\n        data: data\n      });\n      this.emit(\"duration\", {\n        timecodeScale: timecodeScale,\n        duration: duration\n      });\n    }\n  };\n\n  EBMLReader.prototype.read = function (elm) {\n    var _this = this;\n\n    var drop = false;\n\n    if (this.ended) {\n      // reader is finished\n      return;\n    }\n\n    if (elm.type === \"m\") {\n      // 閉じタグの自動挿入\n      if (elm.isEnd) {\n        this.stack.pop();\n      } else {\n        var parent_1 = this.stack[this.stack.length - 1];\n\n        if (parent_1 != null && parent_1.level >= elm.level) {\n          // 閉じタグなしでレベルが下がったら閉じタグを挿入\n          this.stack.pop(); // From http://w3c.github.io/media-source/webm-byte-stream-format.html#webm-media-segments\n          // This fixes logging for webm streams with Cluster of unknown length and no Cluster closing elements.\n\n          if (this.logging) {\n            console.groupEnd();\n          }\n\n          parent_1.dataEnd = elm.dataEnd;\n          parent_1.dataSize = elm.dataEnd - parent_1.dataStart;\n          parent_1.unknownSize = false;\n          var o = Object.assign({}, parent_1, {\n            name: parent_1.name,\n            type: parent_1.type,\n            isEnd: true\n          });\n          this.chunks.push(o);\n        }\n\n        this.stack.push(elm);\n      }\n    }\n\n    if (elm.type === \"m\" && elm.name == \"Segment\") {\n      if (this.segmentOffset != 0) {\n        console.warn(\"Multiple segments detected!\");\n      }\n\n      this.segmentOffset = elm.dataStart;\n      this.emit(\"segment_offset\", this.segmentOffset);\n    } else if (elm.type === \"b\" && elm.name === \"SimpleBlock\") {\n      var _a = tools.ebmlBlock(elm.data),\n          timecode = _a.timecode,\n          trackNumber = _a.trackNumber,\n          frames_1 = _a.frames;\n\n      if (this.trackTypes[trackNumber] === 1) {\n        if (!this.firstVideoBlockRead) {\n          this.firstVideoBlockRead = true;\n\n          if (this.trackInfo.type === \"both\" || this.trackInfo.type === \"video\") {\n            var CueTime = this.lastClusterTimecode + timecode;\n            this.cues.push({\n              CueTrack: trackNumber,\n              CueClusterPosition: this.lastClusterPosition,\n              CueTime: CueTime\n            });\n            this.emit(\"cue_info\", {\n              CueTrack: trackNumber,\n              CueClusterPosition: this.lastClusterPosition,\n              CueTime: this.lastClusterTimecode\n            });\n            this.emit(\"cue\", {\n              CueTrack: trackNumber,\n              CueClusterPosition: this.lastClusterPosition,\n              CueTime: CueTime\n            });\n          }\n        }\n\n        this.last2SimpleBlockVideoTrackTimecode = [this.last2SimpleBlockVideoTrackTimecode[1], timecode];\n      } else if (this.trackTypes[trackNumber] === 2) {\n        if (!this.firstAudioBlockRead) {\n          this.firstAudioBlockRead = true;\n\n          if (this.trackInfo.type === \"audio\") {\n            var CueTime = this.lastClusterTimecode + timecode;\n            this.cues.push({\n              CueTrack: trackNumber,\n              CueClusterPosition: this.lastClusterPosition,\n              CueTime: CueTime\n            });\n            this.emit(\"cue_info\", {\n              CueTrack: trackNumber,\n              CueClusterPosition: this.lastClusterPosition,\n              CueTime: this.lastClusterTimecode\n            });\n            this.emit(\"cue\", {\n              CueTrack: trackNumber,\n              CueClusterPosition: this.lastClusterPosition,\n              CueTime: CueTime\n            });\n          }\n        }\n\n        this.last2SimpleBlockAudioTrackTimecode = [this.last2SimpleBlockAudioTrackTimecode[1], timecode];\n      }\n\n      if (this.use_duration_every_simpleblock) {\n        this.emit(\"duration\", {\n          timecodeScale: this.timecodeScale,\n          duration: this.duration\n        });\n      }\n\n      if (this.use_webp) {\n        frames_1.forEach(function (frame) {\n          var startcode = frame.slice(3, 6).toString(\"hex\");\n\n          if (startcode !== \"9d012a\") {\n            return;\n          }\n\n          ; // VP8 の場合\n\n          var webpBuf = tools.VP8BitStreamToRiffWebPBuffer(frame);\n          var webp = new Blob([webpBuf], {\n            type: \"image/webp\"\n          });\n          var currentTime = _this.duration;\n\n          _this.emit(\"webp\", {\n            currentTime: currentTime,\n            webp: webp\n          });\n        });\n      }\n    } else if (elm.type === \"m\" && elm.name === \"Cluster\" && elm.isEnd === false) {\n      this.firstVideoBlockRead = false;\n      this.firstAudioBlockRead = false;\n      this.emit_segment_info();\n      this.emit(\"cluster_ptr\", elm.tagStart);\n      this.lastClusterPosition = elm.tagStart;\n    } else if (elm.type === \"u\" && elm.name === \"Timecode\") {\n      this.lastClusterTimecode = elm.value;\n    } else if (elm.type === \"u\" && elm.name === \"TimecodeScale\") {\n      this.timecodeScale = elm.value;\n    } else if (elm.type === \"m\" && elm.name === \"TrackEntry\") {\n      if (elm.isEnd) {\n        this.trackTypes[this.currentTrack.TrackNumber] = this.currentTrack.TrackType;\n        this.trackDefaultDuration[this.currentTrack.TrackNumber] = this.currentTrack.DefaultDuration;\n        this.trackCodecDelay[this.currentTrack.TrackNumber] = this.currentTrack.CodecDelay;\n      } else {\n        this.currentTrack = {\n          TrackNumber: -1,\n          TrackType: -1,\n          DefaultDuration: null,\n          CodecDelay: null\n        };\n      }\n    } else if (elm.type === \"u\" && elm.name === \"TrackType\") {\n      this.currentTrack.TrackType = elm.value;\n    } else if (elm.type === \"u\" && elm.name === \"TrackNumber\") {\n      this.currentTrack.TrackNumber = elm.value;\n    } else if (elm.type === \"u\" && elm.name === \"CodecDelay\") {\n      this.currentTrack.CodecDelay = elm.value;\n    } else if (elm.type === \"u\" && elm.name === \"DefaultDuration\") {\n      // media source api は DefaultDuration を計算するとバグる。\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=606000#c22\n      // chrome 58 ではこれを回避するために DefaultDuration 要素を抜き取った。\n      // chrome 58 以前でもこのタグを抜き取ることで回避できる\n      if (this.drop_default_duration) {\n        console.warn(\"DefaultDuration detected!, remove it\");\n        drop = true;\n      } else {\n        this.currentTrack.DefaultDuration = elm.value;\n      }\n    } else if (elm.name === \"unknown\") {\n      console.warn(elm);\n    }\n\n    if (!this.metadataloaded && elm.dataEnd > 0) {\n      this.metadataSize = elm.dataEnd;\n    }\n\n    if (!drop) {\n      this.chunks.push(elm);\n    }\n\n    if (this.logging) {\n      this.put(elm);\n    }\n  };\n\n  Object.defineProperty(EBMLReader.prototype, \"duration\", {\n    /**\n     * DefaultDuration が定義されている場合は最後のフレームのdurationも考慮する\n     * 単位 timecodeScale\n     *\n     * !!! if you need duration with seconds !!!\n     * ```js\n     * const nanosec = reader.duration * reader.timecodeScale;\n     * const sec = nanosec / 1000 / 1000 / 1000;\n     * ```\n     */\n    get: function () {\n      if (this.trackInfo.type === \"nothing\") {\n        console.warn(\"no video, no audio track\");\n        return 0;\n      } // defaultDuration は 生の nano sec\n\n\n      var defaultDuration = 0; // nanoseconds\n\n      var codecDelay = 0;\n      var lastTimecode = 0;\n      var _defaultDuration = this.trackDefaultDuration[this.trackInfo.trackNumber];\n\n      if (typeof _defaultDuration === \"number\") {\n        defaultDuration = _defaultDuration;\n      } else {\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=606000#c22\n        // default duration がないときに使う delta\n        if (this.trackInfo.type === \"both\") {\n          if (this.last2SimpleBlockAudioTrackTimecode[1] > this.last2SimpleBlockVideoTrackTimecode[1]) {\n            // audio diff\n            defaultDuration = (this.last2SimpleBlockAudioTrackTimecode[1] - this.last2SimpleBlockAudioTrackTimecode[0]) * this.timecodeScale; // audio delay\n\n            var delay = this.trackCodecDelay[this.trackTypes.indexOf(2)]; // 2 => audio\n\n            if (typeof delay === \"number\") {\n              codecDelay = delay;\n            } // audio timecode\n\n\n            lastTimecode = this.last2SimpleBlockAudioTrackTimecode[1];\n          } else {\n            // video diff\n            defaultDuration = (this.last2SimpleBlockVideoTrackTimecode[1] - this.last2SimpleBlockVideoTrackTimecode[0]) * this.timecodeScale; // video delay\n\n            var delay = this.trackCodecDelay[this.trackTypes.indexOf(1)]; // 1 => video\n\n            if (typeof delay === \"number\") {\n              codecDelay = delay;\n            } // video timecode\n\n\n            lastTimecode = this.last2SimpleBlockVideoTrackTimecode[1];\n          }\n        } else if (this.trackInfo.type === \"video\") {\n          defaultDuration = (this.last2SimpleBlockVideoTrackTimecode[1] - this.last2SimpleBlockVideoTrackTimecode[0]) * this.timecodeScale;\n          var delay = this.trackCodecDelay[this.trackInfo.trackNumber]; // 2 => audio\n\n          if (typeof delay === \"number\") {\n            codecDelay = delay;\n          }\n\n          lastTimecode = this.last2SimpleBlockVideoTrackTimecode[1];\n        } else if (this.trackInfo.type === \"audio\") {\n          defaultDuration = (this.last2SimpleBlockAudioTrackTimecode[1] - this.last2SimpleBlockAudioTrackTimecode[0]) * this.timecodeScale;\n          var delay = this.trackCodecDelay[this.trackInfo.trackNumber]; // 1 => video\n\n          if (typeof delay === \"number\") {\n            codecDelay = delay;\n          }\n\n          lastTimecode = this.last2SimpleBlockAudioTrackTimecode[1];\n        } // else { not reached }\n\n      } // convert to timecodescale\n\n\n      var duration_nanosec = (this.lastClusterTimecode + lastTimecode) * this.timecodeScale + defaultDuration - codecDelay;\n      var duration = duration_nanosec / this.timecodeScale;\n      return Math.floor(duration);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  EBMLReader.prototype.addListener = function (event, listener) {\n    return _super.prototype.addListener.call(this, event, listener);\n  };\n\n  EBMLReader.prototype.put = function (elm) {\n    if (!this.hasLoggingStarted) {\n      this.hasLoggingStarted = true;\n\n      if (this.logging && this.logGroup) {\n        console.groupCollapsed(this.logGroup);\n      }\n    }\n\n    if (elm.type === \"m\") {\n      if (elm.isEnd) {\n        console.groupEnd();\n      } else {\n        console.group(elm.name + \":\" + elm.tagStart);\n      }\n    } else if (elm.type === \"b\") {\n      // for debug\n      //if(elm.name === \"SimpleBlock\"){\n      //const o = EBML.tools.ebmlBlock(elm.value);\n      //console.log(elm.name, elm.type, o.trackNumber, o.timecode);\n      //}else{\n      console.log(elm.name, elm.type); //}\n    } else {\n      console.log(elm.name, elm.tagStart, elm.type, elm.value);\n    }\n  };\n\n  return EBMLReader;\n}(events_1.EventEmitter);\n\nexports.default = EBMLReader;\n;\n;\n;\n;","map":{"version":3,"sources":["/Users/arnabdhar/Desktop/meetingbuddy/node_modules/ts-ebml/lib/EBMLReader.js"],"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","exports","value","events_1","require","tools","EBMLReader","_super","_this","call","logGroup","hasLoggingStarted","metadataloaded","chunks","stack","segmentOffset","last2SimpleBlockVideoTrackTimecode","last2SimpleBlockAudioTrackTimecode","lastClusterTimecode","lastClusterPosition","timecodeScale","metadataSize","metadatas","cues","firstVideoBlockRead","firstAudioBlockRead","currentTrack","TrackNumber","TrackType","DefaultDuration","CodecDelay","trackTypes","trackDefaultDuration","trackCodecDelay","trackInfo","type","ended","logging","use_duration_every_simpleblock","use_webp","use_segment_info","drop_default_duration","stop","emit_segment_info","length","pop","console","groupEnd","data","videoTrackNum","indexOf","audioTrackNum","trackNumber","emit","timecode","duration","read","elm","drop","isEnd","parent_1","level","dataEnd","dataSize","dataStart","unknownSize","o","assign","name","push","warn","_a","ebmlBlock","frames_1","frames","CueTime","CueTrack","CueClusterPosition","forEach","frame","startcode","slice","toString","webpBuf","VP8BitStreamToRiffWebPBuffer","webp","Blob","currentTime","tagStart","put","get","defaultDuration","codecDelay","lastTimecode","_defaultDuration","delay","duration_nanosec","Math","floor","enumerable","configurable","addListener","event","listener","groupCollapsed","group","log","EventEmitter","default"],"mappings":"AAAA;;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA6B,YAAY;AACrD,MAAIC,aAAa,GAAGC,MAAM,CAACC,cAAP,IACf;AAAEC,IAAAA,SAAS,EAAE;AAAb,eAA6BC,KAA7B,IAAsC,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAAED,IAAAA,CAAC,CAACF,SAAF,GAAcG,CAAd;AAAkB,GAD3D,IAEhB,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AAAE,SAAK,IAAIC,CAAT,IAAcD,CAAd,EAAiB,IAAIA,CAAC,CAACE,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBF,CAAC,CAACE,CAAD,CAAD,GAAOD,CAAC,CAACC,CAAD,CAAR;AAAc,GAF9E;;AAGA,SAAO,UAAUF,CAAV,EAAaC,CAAb,EAAgB;AACnBN,IAAAA,aAAa,CAACK,CAAD,EAAIC,CAAJ,CAAb;;AACA,aAASG,EAAT,GAAc;AAAE,WAAKC,WAAL,GAAmBL,CAAnB;AAAuB;;AACvCA,IAAAA,CAAC,CAACM,SAAF,GAAcL,CAAC,KAAK,IAAN,GAAaL,MAAM,CAACW,MAAP,CAAcN,CAAd,CAAb,IAAiCG,EAAE,CAACE,SAAH,GAAeL,CAAC,CAACK,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,GAJD;AAKH,CAT2C,EAA5C;;AAUAR,MAAM,CAACY,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAAnB;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIE,UAAU,GAAI,UAAUC,MAAV,EAAkB;AAChCrB,EAAAA,SAAS,CAACoB,UAAD,EAAaC,MAAb,CAAT;;AACA,WAASD,UAAT,GAAsB;AAClB,QAAIE,KAAK,GAAGD,MAAM,CAACE,IAAP,CAAY,IAAZ,KAAqB,IAAjC;;AACAD,IAAAA,KAAK,CAACE,QAAN,GAAiB,EAAjB;AACAF,IAAAA,KAAK,CAACG,iBAAN,GAA0B,KAA1B;AACAH,IAAAA,KAAK,CAACI,cAAN,GAAuB,KAAvB;AACAJ,IAAAA,KAAK,CAACK,MAAN,GAAe,EAAf;AACAL,IAAAA,KAAK,CAACM,KAAN,GAAc,EAAd;AACAN,IAAAA,KAAK,CAACO,aAAN,GAAsB,CAAtB;AACAP,IAAAA,KAAK,CAACQ,kCAAN,GAA2C,CAAC,CAAD,EAAI,CAAJ,CAA3C;AACAR,IAAAA,KAAK,CAACS,kCAAN,GAA2C,CAAC,CAAD,EAAI,CAAJ,CAA3C;AACAT,IAAAA,KAAK,CAACU,mBAAN,GAA4B,CAA5B;AACAV,IAAAA,KAAK,CAACW,mBAAN,GAA4B,CAA5B;AACAX,IAAAA,KAAK,CAACY,aAAN,GAAsB,OAAtB,CAZkB,CAYa;;AAC/BZ,IAAAA,KAAK,CAACa,YAAN,GAAqB,CAArB;AACAb,IAAAA,KAAK,CAACc,SAAN,GAAkB,EAAlB;AACAd,IAAAA,KAAK,CAACe,IAAN,GAAa,EAAb;AACAf,IAAAA,KAAK,CAACgB,mBAAN,GAA4B,KAA5B;AACAhB,IAAAA,KAAK,CAACiB,mBAAN,GAA4B,KAA5B;AACAjB,IAAAA,KAAK,CAACkB,YAAN,GAAqB;AAAEC,MAAAA,WAAW,EAAE,CAAC,CAAhB;AAAmBC,MAAAA,SAAS,EAAE,CAAC,CAA/B;AAAkCC,MAAAA,eAAe,EAAE,IAAnD;AAAyDC,MAAAA,UAAU,EAAE;AAArE,KAArB;AACAtB,IAAAA,KAAK,CAACuB,UAAN,GAAmB,EAAnB;AACAvB,IAAAA,KAAK,CAACwB,oBAAN,GAA6B,EAA7B;AACAxB,IAAAA,KAAK,CAACyB,eAAN,GAAwB,EAAxB;AACAzB,IAAAA,KAAK,CAAC0B,SAAN,GAAkB;AAAEC,MAAAA,IAAI,EAAE;AAAR,KAAlB;AACA3B,IAAAA,KAAK,CAAC4B,KAAN,GAAc,KAAd;AACA5B,IAAAA,KAAK,CAAC6B,OAAN,GAAgB,KAAhB;AACA7B,IAAAA,KAAK,CAAC8B,8BAAN,GAAuC,KAAvC;AACA9B,IAAAA,KAAK,CAAC+B,QAAN,GAAiB,KAAjB;AACA/B,IAAAA,KAAK,CAACgC,gBAAN,GAAyB,IAAzB;AACAhC,IAAAA,KAAK,CAACiC,qBAAN,GAA8B,IAA9B;AACA,WAAOjC,KAAP;AACH;AACD;AACJ;AACA;;;AACIF,EAAAA,UAAU,CAACR,SAAX,CAAqB4C,IAArB,GAA4B,YAAY;AACpC,SAAKN,KAAL,GAAa,IAAb;AACA,SAAKO,iBAAL,GAFoC,CAGpC;;AACA,WAAO,KAAK7B,KAAL,CAAW8B,MAAlB,EAA0B;AACtB,WAAK9B,KAAL,CAAW+B,GAAX;;AACA,UAAI,KAAKR,OAAT,EAAkB;AACdS,QAAAA,OAAO,CAACC,QAAR;AACH;AACJ,KATmC,CAUpC;;;AACA,QAAI,KAAKV,OAAL,IAAgB,KAAK1B,iBAArB,IAA0C,KAAKD,QAAnD,EAA6D;AACzDoC,MAAAA,OAAO,CAACC,QAAR;AACH;AACJ,GAdD;AAeA;AACJ;AACA;;;AACIzC,EAAAA,UAAU,CAACR,SAAX,CAAqB6C,iBAArB,GAAyC,YAAY;AACjD,QAAIK,IAAI,GAAG,KAAKnC,MAAhB;AACA,SAAKA,MAAL,GAAc,EAAd;;AACA,QAAI,CAAC,KAAKD,cAAV,EAA0B;AACtB,WAAKA,cAAL,GAAsB,IAAtB;AACA,WAAKU,SAAL,GAAiB0B,IAAjB;AACA,UAAIC,aAAa,GAAG,KAAKlB,UAAL,CAAgBmB,OAAhB,CAAwB,CAAxB,CAApB,CAHsB,CAG0B;;AAChD,UAAIC,aAAa,GAAG,KAAKpB,UAAL,CAAgBmB,OAAhB,CAAwB,CAAxB,CAApB,CAJsB,CAI0B;;AAChD,WAAKhB,SAAL,GAAiBe,aAAa,IAAI,CAAjB,IAAsBE,aAAa,IAAI,CAAvC,GAA2C;AAAEhB,QAAAA,IAAI,EAAE,MAAR;AAAgBiB,QAAAA,WAAW,EAAEH;AAA7B,OAA3C,GACXA,aAAa,IAAI,CAAjB,GAAqB;AAAEd,QAAAA,IAAI,EAAE,OAAR;AAAiBiB,QAAAA,WAAW,EAAEH;AAA9B,OAArB,GACIE,aAAa,IAAI,CAAjB,GAAqB;AAAEhB,QAAAA,IAAI,EAAE,OAAR;AAAiBiB,QAAAA,WAAW,EAAED;AAA9B,OAArB,GACI;AAAEhB,QAAAA,IAAI,EAAE;AAAR,OAHd;;AAIA,UAAI,CAAC,KAAKK,gBAAV,EAA4B;AACxB;AACH;;AACD,WAAKa,IAAL,CAAU,UAAV,EAAsB;AAAEL,QAAAA,IAAI,EAAEA,IAAR;AAAc3B,QAAAA,YAAY,EAAE,KAAKA;AAAjC,OAAtB;AACH,KAbD,MAcK;AACD,UAAI,CAAC,KAAKmB,gBAAV,EAA4B;AACxB;AACH;;AACD,UAAIc,QAAQ,GAAG,KAAKpC,mBAApB;AACA,UAAIqC,QAAQ,GAAG,KAAKA,QAApB;AACA,UAAInC,aAAa,GAAG,KAAKA,aAAzB;AACA,WAAKiC,IAAL,CAAU,SAAV,EAAqB;AAAEC,QAAAA,QAAQ,EAAEA,QAAZ;AAAsBN,QAAAA,IAAI,EAAEA;AAA5B,OAArB;AACA,WAAKK,IAAL,CAAU,UAAV,EAAsB;AAAEjC,QAAAA,aAAa,EAAEA,aAAjB;AAAgCmC,QAAAA,QAAQ,EAAEA;AAA1C,OAAtB;AACH;AACJ,GA3BD;;AA4BAjD,EAAAA,UAAU,CAACR,SAAX,CAAqB0D,IAArB,GAA4B,UAAUC,GAAV,EAAe;AACvC,QAAIjD,KAAK,GAAG,IAAZ;;AACA,QAAIkD,IAAI,GAAG,KAAX;;AACA,QAAI,KAAKtB,KAAT,EAAgB;AACZ;AACA;AACH;;AACD,QAAIqB,GAAG,CAACtB,IAAJ,KAAa,GAAjB,EAAsB;AAClB;AACA,UAAIsB,GAAG,CAACE,KAAR,EAAe;AACX,aAAK7C,KAAL,CAAW+B,GAAX;AACH,OAFD,MAGK;AACD,YAAIe,QAAQ,GAAG,KAAK9C,KAAL,CAAW,KAAKA,KAAL,CAAW8B,MAAX,GAAoB,CAA/B,CAAf;;AACA,YAAIgB,QAAQ,IAAI,IAAZ,IAAoBA,QAAQ,CAACC,KAAT,IAAkBJ,GAAG,CAACI,KAA9C,EAAqD;AACjD;AACA,eAAK/C,KAAL,CAAW+B,GAAX,GAFiD,CAGjD;AACA;;AACA,cAAI,KAAKR,OAAT,EAAkB;AACdS,YAAAA,OAAO,CAACC,QAAR;AACH;;AACDa,UAAAA,QAAQ,CAACE,OAAT,GAAmBL,GAAG,CAACK,OAAvB;AACAF,UAAAA,QAAQ,CAACG,QAAT,GAAoBN,GAAG,CAACK,OAAJ,GAAcF,QAAQ,CAACI,SAA3C;AACAJ,UAAAA,QAAQ,CAACK,WAAT,GAAuB,KAAvB;AACA,cAAIC,CAAC,GAAG9E,MAAM,CAAC+E,MAAP,CAAc,EAAd,EAAkBP,QAAlB,EAA4B;AAAEQ,YAAAA,IAAI,EAAER,QAAQ,CAACQ,IAAjB;AAAuBjC,YAAAA,IAAI,EAAEyB,QAAQ,CAACzB,IAAtC;AAA4CwB,YAAAA,KAAK,EAAE;AAAnD,WAA5B,CAAR;AACA,eAAK9C,MAAL,CAAYwD,IAAZ,CAAiBH,CAAjB;AACH;;AACD,aAAKpD,KAAL,CAAWuD,IAAX,CAAgBZ,GAAhB;AACH;AACJ;;AACD,QAAIA,GAAG,CAACtB,IAAJ,KAAa,GAAb,IAAoBsB,GAAG,CAACW,IAAJ,IAAY,SAApC,EAA+C;AAC3C,UAAI,KAAKrD,aAAL,IAAsB,CAA1B,EAA6B;AACzB+B,QAAAA,OAAO,CAACwB,IAAR,CAAa,6BAAb;AACH;;AACD,WAAKvD,aAAL,GAAqB0C,GAAG,CAACO,SAAzB;AACA,WAAKX,IAAL,CAAU,gBAAV,EAA4B,KAAKtC,aAAjC;AACH,KAND,MAOK,IAAI0C,GAAG,CAACtB,IAAJ,KAAa,GAAb,IAAoBsB,GAAG,CAACW,IAAJ,KAAa,aAArC,EAAoD;AACrD,UAAIG,EAAE,GAAGlE,KAAK,CAACmE,SAAN,CAAgBf,GAAG,CAACT,IAApB,CAAT;AAAA,UAAoCM,QAAQ,GAAGiB,EAAE,CAACjB,QAAlD;AAAA,UAA4DF,WAAW,GAAGmB,EAAE,CAACnB,WAA7E;AAAA,UAA0FqB,QAAQ,GAAGF,EAAE,CAACG,MAAxG;;AACA,UAAI,KAAK3C,UAAL,CAAgBqB,WAAhB,MAAiC,CAArC,EAAwC;AACpC,YAAI,CAAC,KAAK5B,mBAAV,EAA+B;AAC3B,eAAKA,mBAAL,GAA2B,IAA3B;;AACA,cAAI,KAAKU,SAAL,CAAeC,IAAf,KAAwB,MAAxB,IAAkC,KAAKD,SAAL,CAAeC,IAAf,KAAwB,OAA9D,EAAuE;AACnE,gBAAIwC,OAAO,GAAG,KAAKzD,mBAAL,GAA2BoC,QAAzC;AACA,iBAAK/B,IAAL,CAAU8C,IAAV,CAAe;AAAEO,cAAAA,QAAQ,EAAExB,WAAZ;AAAyByB,cAAAA,kBAAkB,EAAE,KAAK1D,mBAAlD;AAAuEwD,cAAAA,OAAO,EAAEA;AAAhF,aAAf;AACA,iBAAKtB,IAAL,CAAU,UAAV,EAAsB;AAAEuB,cAAAA,QAAQ,EAAExB,WAAZ;AAAyByB,cAAAA,kBAAkB,EAAE,KAAK1D,mBAAlD;AAAuEwD,cAAAA,OAAO,EAAE,KAAKzD;AAArF,aAAtB;AACA,iBAAKmC,IAAL,CAAU,KAAV,EAAiB;AAAEuB,cAAAA,QAAQ,EAAExB,WAAZ;AAAyByB,cAAAA,kBAAkB,EAAE,KAAK1D,mBAAlD;AAAuEwD,cAAAA,OAAO,EAAEA;AAAhF,aAAjB;AACH;AACJ;;AACD,aAAK3D,kCAAL,GAA0C,CAAC,KAAKA,kCAAL,CAAwC,CAAxC,CAAD,EAA6CsC,QAA7C,CAA1C;AACH,OAXD,MAYK,IAAI,KAAKvB,UAAL,CAAgBqB,WAAhB,MAAiC,CAArC,EAAwC;AACzC,YAAI,CAAC,KAAK3B,mBAAV,EAA+B;AAC3B,eAAKA,mBAAL,GAA2B,IAA3B;;AACA,cAAI,KAAKS,SAAL,CAAeC,IAAf,KAAwB,OAA5B,EAAqC;AACjC,gBAAIwC,OAAO,GAAG,KAAKzD,mBAAL,GAA2BoC,QAAzC;AACA,iBAAK/B,IAAL,CAAU8C,IAAV,CAAe;AAAEO,cAAAA,QAAQ,EAAExB,WAAZ;AAAyByB,cAAAA,kBAAkB,EAAE,KAAK1D,mBAAlD;AAAuEwD,cAAAA,OAAO,EAAEA;AAAhF,aAAf;AACA,iBAAKtB,IAAL,CAAU,UAAV,EAAsB;AAAEuB,cAAAA,QAAQ,EAAExB,WAAZ;AAAyByB,cAAAA,kBAAkB,EAAE,KAAK1D,mBAAlD;AAAuEwD,cAAAA,OAAO,EAAE,KAAKzD;AAArF,aAAtB;AACA,iBAAKmC,IAAL,CAAU,KAAV,EAAiB;AAAEuB,cAAAA,QAAQ,EAAExB,WAAZ;AAAyByB,cAAAA,kBAAkB,EAAE,KAAK1D,mBAAlD;AAAuEwD,cAAAA,OAAO,EAAEA;AAAhF,aAAjB;AACH;AACJ;;AACD,aAAK1D,kCAAL,GAA0C,CAAC,KAAKA,kCAAL,CAAwC,CAAxC,CAAD,EAA6CqC,QAA7C,CAA1C;AACH;;AACD,UAAI,KAAKhB,8BAAT,EAAyC;AACrC,aAAKe,IAAL,CAAU,UAAV,EAAsB;AAAEjC,UAAAA,aAAa,EAAE,KAAKA,aAAtB;AAAqCmC,UAAAA,QAAQ,EAAE,KAAKA;AAApD,SAAtB;AACH;;AACD,UAAI,KAAKhB,QAAT,EAAmB;AACfkC,QAAAA,QAAQ,CAACK,OAAT,CAAiB,UAAUC,KAAV,EAAiB;AAC9B,cAAIC,SAAS,GAAGD,KAAK,CAACE,KAAN,CAAY,CAAZ,EAAe,CAAf,EAAkBC,QAAlB,CAA2B,KAA3B,CAAhB;;AACA,cAAIF,SAAS,KAAK,QAAlB,EAA4B;AACxB;AACH;;AACD,WAL8B,CAK5B;;AACF,cAAIG,OAAO,GAAG9E,KAAK,CAAC+E,4BAAN,CAAmCL,KAAnC,CAAd;AACA,cAAIM,IAAI,GAAG,IAAIC,IAAJ,CAAS,CAACH,OAAD,CAAT,EAAoB;AAAEhD,YAAAA,IAAI,EAAE;AAAR,WAApB,CAAX;AACA,cAAIoD,WAAW,GAAG/E,KAAK,CAAC+C,QAAxB;;AACA/C,UAAAA,KAAK,CAAC6C,IAAN,CAAW,MAAX,EAAmB;AAAEkC,YAAAA,WAAW,EAAEA,WAAf;AAA4BF,YAAAA,IAAI,EAAEA;AAAlC,WAAnB;AACH,SAVD;AAWH;AACJ,KA1CI,MA2CA,IAAI5B,GAAG,CAACtB,IAAJ,KAAa,GAAb,IAAoBsB,GAAG,CAACW,IAAJ,KAAa,SAAjC,IAA8CX,GAAG,CAACE,KAAJ,KAAc,KAAhE,EAAuE;AACxE,WAAKnC,mBAAL,GAA2B,KAA3B;AACA,WAAKC,mBAAL,GAA2B,KAA3B;AACA,WAAKkB,iBAAL;AACA,WAAKU,IAAL,CAAU,aAAV,EAAyBI,GAAG,CAAC+B,QAA7B;AACA,WAAKrE,mBAAL,GAA2BsC,GAAG,CAAC+B,QAA/B;AACH,KANI,MAOA,IAAI/B,GAAG,CAACtB,IAAJ,KAAa,GAAb,IAAoBsB,GAAG,CAACW,IAAJ,KAAa,UAArC,EAAiD;AAClD,WAAKlD,mBAAL,GAA2BuC,GAAG,CAACvD,KAA/B;AACH,KAFI,MAGA,IAAIuD,GAAG,CAACtB,IAAJ,KAAa,GAAb,IAAoBsB,GAAG,CAACW,IAAJ,KAAa,eAArC,EAAsD;AACvD,WAAKhD,aAAL,GAAqBqC,GAAG,CAACvD,KAAzB;AACH,KAFI,MAGA,IAAIuD,GAAG,CAACtB,IAAJ,KAAa,GAAb,IAAoBsB,GAAG,CAACW,IAAJ,KAAa,YAArC,EAAmD;AACpD,UAAIX,GAAG,CAACE,KAAR,EAAe;AACX,aAAK5B,UAAL,CAAgB,KAAKL,YAAL,CAAkBC,WAAlC,IAAiD,KAAKD,YAAL,CAAkBE,SAAnE;AACA,aAAKI,oBAAL,CAA0B,KAAKN,YAAL,CAAkBC,WAA5C,IAA2D,KAAKD,YAAL,CAAkBG,eAA7E;AACA,aAAKI,eAAL,CAAqB,KAAKP,YAAL,CAAkBC,WAAvC,IAAsD,KAAKD,YAAL,CAAkBI,UAAxE;AACH,OAJD,MAKK;AACD,aAAKJ,YAAL,GAAoB;AAAEC,UAAAA,WAAW,EAAE,CAAC,CAAhB;AAAmBC,UAAAA,SAAS,EAAE,CAAC,CAA/B;AAAkCC,UAAAA,eAAe,EAAE,IAAnD;AAAyDC,UAAAA,UAAU,EAAE;AAArE,SAApB;AACH;AACJ,KATI,MAUA,IAAI2B,GAAG,CAACtB,IAAJ,KAAa,GAAb,IAAoBsB,GAAG,CAACW,IAAJ,KAAa,WAArC,EAAkD;AACnD,WAAK1C,YAAL,CAAkBE,SAAlB,GAA8B6B,GAAG,CAACvD,KAAlC;AACH,KAFI,MAGA,IAAIuD,GAAG,CAACtB,IAAJ,KAAa,GAAb,IAAoBsB,GAAG,CAACW,IAAJ,KAAa,aAArC,EAAoD;AACrD,WAAK1C,YAAL,CAAkBC,WAAlB,GAAgC8B,GAAG,CAACvD,KAApC;AACH,KAFI,MAGA,IAAIuD,GAAG,CAACtB,IAAJ,KAAa,GAAb,IAAoBsB,GAAG,CAACW,IAAJ,KAAa,YAArC,EAAmD;AACpD,WAAK1C,YAAL,CAAkBI,UAAlB,GAA+B2B,GAAG,CAACvD,KAAnC;AACH,KAFI,MAGA,IAAIuD,GAAG,CAACtB,IAAJ,KAAa,GAAb,IAAoBsB,GAAG,CAACW,IAAJ,KAAa,iBAArC,EAAwD;AACzD;AACA;AACA;AACA;AACA,UAAI,KAAK3B,qBAAT,EAAgC;AAC5BK,QAAAA,OAAO,CAACwB,IAAR,CAAa,sCAAb;AACAZ,QAAAA,IAAI,GAAG,IAAP;AACH,OAHD,MAIK;AACD,aAAKhC,YAAL,CAAkBG,eAAlB,GAAoC4B,GAAG,CAACvD,KAAxC;AACH;AACJ,KAZI,MAaA,IAAIuD,GAAG,CAACW,IAAJ,KAAa,SAAjB,EAA4B;AAC7BtB,MAAAA,OAAO,CAACwB,IAAR,CAAab,GAAb;AACH;;AACD,QAAI,CAAC,KAAK7C,cAAN,IAAwB6C,GAAG,CAACK,OAAJ,GAAc,CAA1C,EAA6C;AACzC,WAAKzC,YAAL,GAAoBoC,GAAG,CAACK,OAAxB;AACH;;AACD,QAAI,CAACJ,IAAL,EAAW;AACP,WAAK7C,MAAL,CAAYwD,IAAZ,CAAiBZ,GAAjB;AACH;;AACD,QAAI,KAAKpB,OAAT,EAAkB;AACd,WAAKoD,GAAL,CAAShC,GAAT;AACH;AACJ,GA1ID;;AA2IArE,EAAAA,MAAM,CAACY,cAAP,CAAsBM,UAAU,CAACR,SAAjC,EAA4C,UAA5C,EAAwD;AACpD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQ4F,IAAAA,GAAG,EAAE,YAAY;AACb,UAAI,KAAKxD,SAAL,CAAeC,IAAf,KAAwB,SAA5B,EAAuC;AACnCW,QAAAA,OAAO,CAACwB,IAAR,CAAa,0BAAb;AACA,eAAO,CAAP;AACH,OAJY,CAKb;;;AACA,UAAIqB,eAAe,GAAG,CAAtB,CANa,CAOb;;AACA,UAAIC,UAAU,GAAG,CAAjB;AACA,UAAIC,YAAY,GAAG,CAAnB;AACA,UAAIC,gBAAgB,GAAG,KAAK9D,oBAAL,CAA0B,KAAKE,SAAL,CAAekB,WAAzC,CAAvB;;AACA,UAAI,OAAO0C,gBAAP,KAA4B,QAAhC,EAA0C;AACtCH,QAAAA,eAAe,GAAGG,gBAAlB;AACH,OAFD,MAGK;AACD;AACA;AACA,YAAI,KAAK5D,SAAL,CAAeC,IAAf,KAAwB,MAA5B,EAAoC;AAChC,cAAI,KAAKlB,kCAAL,CAAwC,CAAxC,IAA6C,KAAKD,kCAAL,CAAwC,CAAxC,CAAjD,EAA6F;AACzF;AACA2E,YAAAA,eAAe,GAAG,CAAC,KAAK1E,kCAAL,CAAwC,CAAxC,IAA6C,KAAKA,kCAAL,CAAwC,CAAxC,CAA9C,IAA4F,KAAKG,aAAnH,CAFyF,CAGzF;;AACA,gBAAI2E,KAAK,GAAG,KAAK9D,eAAL,CAAqB,KAAKF,UAAL,CAAgBmB,OAAhB,CAAwB,CAAxB,CAArB,CAAZ,CAJyF,CAI3B;;AAC9D,gBAAI,OAAO6C,KAAP,KAAiB,QAArB,EAA+B;AAC3BH,cAAAA,UAAU,GAAGG,KAAb;AACH,aAPwF,CAQzF;;;AACAF,YAAAA,YAAY,GAAG,KAAK5E,kCAAL,CAAwC,CAAxC,CAAf;AACH,WAVD,MAWK;AACD;AACA0E,YAAAA,eAAe,GAAG,CAAC,KAAK3E,kCAAL,CAAwC,CAAxC,IAA6C,KAAKA,kCAAL,CAAwC,CAAxC,CAA9C,IAA4F,KAAKI,aAAnH,CAFC,CAGD;;AACA,gBAAI2E,KAAK,GAAG,KAAK9D,eAAL,CAAqB,KAAKF,UAAL,CAAgBmB,OAAhB,CAAwB,CAAxB,CAArB,CAAZ,CAJC,CAI6D;;AAC9D,gBAAI,OAAO6C,KAAP,KAAiB,QAArB,EAA+B;AAC3BH,cAAAA,UAAU,GAAGG,KAAb;AACH,aAPA,CAQD;;;AACAF,YAAAA,YAAY,GAAG,KAAK7E,kCAAL,CAAwC,CAAxC,CAAf;AACH;AACJ,SAvBD,MAwBK,IAAI,KAAKkB,SAAL,CAAeC,IAAf,KAAwB,OAA5B,EAAqC;AACtCwD,UAAAA,eAAe,GAAG,CAAC,KAAK3E,kCAAL,CAAwC,CAAxC,IAA6C,KAAKA,kCAAL,CAAwC,CAAxC,CAA9C,IAA4F,KAAKI,aAAnH;AACA,cAAI2E,KAAK,GAAG,KAAK9D,eAAL,CAAqB,KAAKC,SAAL,CAAekB,WAApC,CAAZ,CAFsC,CAEwB;;AAC9D,cAAI,OAAO2C,KAAP,KAAiB,QAArB,EAA+B;AAC3BH,YAAAA,UAAU,GAAGG,KAAb;AACH;;AACDF,UAAAA,YAAY,GAAG,KAAK7E,kCAAL,CAAwC,CAAxC,CAAf;AACH,SAPI,MAQA,IAAI,KAAKkB,SAAL,CAAeC,IAAf,KAAwB,OAA5B,EAAqC;AACtCwD,UAAAA,eAAe,GAAG,CAAC,KAAK1E,kCAAL,CAAwC,CAAxC,IAA6C,KAAKA,kCAAL,CAAwC,CAAxC,CAA9C,IAA4F,KAAKG,aAAnH;AACA,cAAI2E,KAAK,GAAG,KAAK9D,eAAL,CAAqB,KAAKC,SAAL,CAAekB,WAApC,CAAZ,CAFsC,CAEwB;;AAC9D,cAAI,OAAO2C,KAAP,KAAiB,QAArB,EAA+B;AAC3BH,YAAAA,UAAU,GAAGG,KAAb;AACH;;AACDF,UAAAA,YAAY,GAAG,KAAK5E,kCAAL,CAAwC,CAAxC,CAAf;AACH,SA1CA,CA0CC;;AACL,OAzDY,CA0Db;;;AACA,UAAI+E,gBAAgB,GAAI,CAAC,KAAK9E,mBAAL,GAA2B2E,YAA5B,IAA4C,KAAKzE,aAAlD,GAAmEuE,eAAnE,GAAqFC,UAA5G;AACA,UAAIrC,QAAQ,GAAGyC,gBAAgB,GAAG,KAAK5E,aAAvC;AACA,aAAO6E,IAAI,CAACC,KAAL,CAAW3C,QAAX,CAAP;AACH,KAzEmD;AA0EpD4C,IAAAA,UAAU,EAAE,IA1EwC;AA2EpDC,IAAAA,YAAY,EAAE;AA3EsC,GAAxD;;AA6EA9F,EAAAA,UAAU,CAACR,SAAX,CAAqBuG,WAArB,GAAmC,UAAUC,KAAV,EAAiBC,QAAjB,EAA2B;AAC1D,WAAOhG,MAAM,CAACT,SAAP,CAAiBuG,WAAjB,CAA6B5F,IAA7B,CAAkC,IAAlC,EAAwC6F,KAAxC,EAA+CC,QAA/C,CAAP;AACH,GAFD;;AAGAjG,EAAAA,UAAU,CAACR,SAAX,CAAqB2F,GAArB,GAA2B,UAAUhC,GAAV,EAAe;AACtC,QAAI,CAAC,KAAK9C,iBAAV,EAA6B;AACzB,WAAKA,iBAAL,GAAyB,IAAzB;;AACA,UAAI,KAAK0B,OAAL,IAAgB,KAAK3B,QAAzB,EAAmC;AAC/BoC,QAAAA,OAAO,CAAC0D,cAAR,CAAuB,KAAK9F,QAA5B;AACH;AACJ;;AACD,QAAI+C,GAAG,CAACtB,IAAJ,KAAa,GAAjB,EAAsB;AAClB,UAAIsB,GAAG,CAACE,KAAR,EAAe;AACXb,QAAAA,OAAO,CAACC,QAAR;AACH,OAFD,MAGK;AACDD,QAAAA,OAAO,CAAC2D,KAAR,CAAchD,GAAG,CAACW,IAAJ,GAAW,GAAX,GAAiBX,GAAG,CAAC+B,QAAnC;AACH;AACJ,KAPD,MAQK,IAAI/B,GAAG,CAACtB,IAAJ,KAAa,GAAjB,EAAsB;AACvB;AACA;AACA;AACA;AACA;AACAW,MAAAA,OAAO,CAAC4D,GAAR,CAAYjD,GAAG,CAACW,IAAhB,EAAsBX,GAAG,CAACtB,IAA1B,EANuB,CAOvB;AACH,KARI,MASA;AACDW,MAAAA,OAAO,CAAC4D,GAAR,CAAYjD,GAAG,CAACW,IAAhB,EAAsBX,GAAG,CAAC+B,QAA1B,EAAoC/B,GAAG,CAACtB,IAAxC,EAA8CsB,GAAG,CAACvD,KAAlD;AACH;AACJ,GA3BD;;AA4BA,SAAOI,UAAP;AACH,CA1UiB,CA0UhBH,QAAQ,CAACwG,YA1UO,CAAlB;;AA2UA1G,OAAO,CAAC2G,OAAR,GAAkBtG,UAAlB;AACA;AACA;AACA;AACA","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar events_1 = require(\"events\");\nvar tools = require(\"./tools\");\n/**\n * This is an informal code for reference.\n * EBMLReader is a class for getting information to enable seeking Webm recorded by MediaRecorder.\n * So please do not use for regular WebM files.\n */\nvar EBMLReader = (function (_super) {\n    __extends(EBMLReader, _super);\n    function EBMLReader() {\n        var _this = _super.call(this) || this;\n        _this.logGroup = \"\";\n        _this.hasLoggingStarted = false;\n        _this.metadataloaded = false;\n        _this.chunks = [];\n        _this.stack = [];\n        _this.segmentOffset = 0;\n        _this.last2SimpleBlockVideoTrackTimecode = [0, 0];\n        _this.last2SimpleBlockAudioTrackTimecode = [0, 0];\n        _this.lastClusterTimecode = 0;\n        _this.lastClusterPosition = 0;\n        _this.timecodeScale = 1000000; // webm default TimecodeScale is 1ms\n        _this.metadataSize = 0;\n        _this.metadatas = [];\n        _this.cues = [];\n        _this.firstVideoBlockRead = false;\n        _this.firstAudioBlockRead = false;\n        _this.currentTrack = { TrackNumber: -1, TrackType: -1, DefaultDuration: null, CodecDelay: null };\n        _this.trackTypes = [];\n        _this.trackDefaultDuration = [];\n        _this.trackCodecDelay = [];\n        _this.trackInfo = { type: \"nothing\" };\n        _this.ended = false;\n        _this.logging = false;\n        _this.use_duration_every_simpleblock = false;\n        _this.use_webp = false;\n        _this.use_segment_info = true;\n        _this.drop_default_duration = true;\n        return _this;\n    }\n    /**\n     * emit final state.\n     */\n    EBMLReader.prototype.stop = function () {\n        this.ended = true;\n        this.emit_segment_info();\n        // clean up any unclosed Master Elements at the end of the stream.\n        while (this.stack.length) {\n            this.stack.pop();\n            if (this.logging) {\n                console.groupEnd();\n            }\n        }\n        // close main group if set, logging is enabled, and has actually logged anything.\n        if (this.logging && this.hasLoggingStarted && this.logGroup) {\n            console.groupEnd();\n        }\n    };\n    /**\n     * emit chunk info\n     */\n    EBMLReader.prototype.emit_segment_info = function () {\n        var data = this.chunks;\n        this.chunks = [];\n        if (!this.metadataloaded) {\n            this.metadataloaded = true;\n            this.metadatas = data;\n            var videoTrackNum = this.trackTypes.indexOf(1); // find first video track\n            var audioTrackNum = this.trackTypes.indexOf(2); // find first audio track\n            this.trackInfo = videoTrackNum >= 0 && audioTrackNum >= 0 ? { type: \"both\", trackNumber: videoTrackNum }\n                : videoTrackNum >= 0 ? { type: \"video\", trackNumber: videoTrackNum }\n                    : audioTrackNum >= 0 ? { type: \"audio\", trackNumber: audioTrackNum }\n                        : { type: \"nothing\" };\n            if (!this.use_segment_info) {\n                return;\n            }\n            this.emit(\"metadata\", { data: data, metadataSize: this.metadataSize });\n        }\n        else {\n            if (!this.use_segment_info) {\n                return;\n            }\n            var timecode = this.lastClusterTimecode;\n            var duration = this.duration;\n            var timecodeScale = this.timecodeScale;\n            this.emit(\"cluster\", { timecode: timecode, data: data });\n            this.emit(\"duration\", { timecodeScale: timecodeScale, duration: duration });\n        }\n    };\n    EBMLReader.prototype.read = function (elm) {\n        var _this = this;\n        var drop = false;\n        if (this.ended) {\n            // reader is finished\n            return;\n        }\n        if (elm.type === \"m\") {\n            // 閉じタグの自動挿入\n            if (elm.isEnd) {\n                this.stack.pop();\n            }\n            else {\n                var parent_1 = this.stack[this.stack.length - 1];\n                if (parent_1 != null && parent_1.level >= elm.level) {\n                    // 閉じタグなしでレベルが下がったら閉じタグを挿入\n                    this.stack.pop();\n                    // From http://w3c.github.io/media-source/webm-byte-stream-format.html#webm-media-segments\n                    // This fixes logging for webm streams with Cluster of unknown length and no Cluster closing elements.\n                    if (this.logging) {\n                        console.groupEnd();\n                    }\n                    parent_1.dataEnd = elm.dataEnd;\n                    parent_1.dataSize = elm.dataEnd - parent_1.dataStart;\n                    parent_1.unknownSize = false;\n                    var o = Object.assign({}, parent_1, { name: parent_1.name, type: parent_1.type, isEnd: true });\n                    this.chunks.push(o);\n                }\n                this.stack.push(elm);\n            }\n        }\n        if (elm.type === \"m\" && elm.name == \"Segment\") {\n            if (this.segmentOffset != 0) {\n                console.warn(\"Multiple segments detected!\");\n            }\n            this.segmentOffset = elm.dataStart;\n            this.emit(\"segment_offset\", this.segmentOffset);\n        }\n        else if (elm.type === \"b\" && elm.name === \"SimpleBlock\") {\n            var _a = tools.ebmlBlock(elm.data), timecode = _a.timecode, trackNumber = _a.trackNumber, frames_1 = _a.frames;\n            if (this.trackTypes[trackNumber] === 1) {\n                if (!this.firstVideoBlockRead) {\n                    this.firstVideoBlockRead = true;\n                    if (this.trackInfo.type === \"both\" || this.trackInfo.type === \"video\") {\n                        var CueTime = this.lastClusterTimecode + timecode;\n                        this.cues.push({ CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: CueTime });\n                        this.emit(\"cue_info\", { CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: this.lastClusterTimecode });\n                        this.emit(\"cue\", { CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: CueTime });\n                    }\n                }\n                this.last2SimpleBlockVideoTrackTimecode = [this.last2SimpleBlockVideoTrackTimecode[1], timecode];\n            }\n            else if (this.trackTypes[trackNumber] === 2) {\n                if (!this.firstAudioBlockRead) {\n                    this.firstAudioBlockRead = true;\n                    if (this.trackInfo.type === \"audio\") {\n                        var CueTime = this.lastClusterTimecode + timecode;\n                        this.cues.push({ CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: CueTime });\n                        this.emit(\"cue_info\", { CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: this.lastClusterTimecode });\n                        this.emit(\"cue\", { CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: CueTime });\n                    }\n                }\n                this.last2SimpleBlockAudioTrackTimecode = [this.last2SimpleBlockAudioTrackTimecode[1], timecode];\n            }\n            if (this.use_duration_every_simpleblock) {\n                this.emit(\"duration\", { timecodeScale: this.timecodeScale, duration: this.duration });\n            }\n            if (this.use_webp) {\n                frames_1.forEach(function (frame) {\n                    var startcode = frame.slice(3, 6).toString(\"hex\");\n                    if (startcode !== \"9d012a\") {\n                        return;\n                    }\n                    ; // VP8 の場合\n                    var webpBuf = tools.VP8BitStreamToRiffWebPBuffer(frame);\n                    var webp = new Blob([webpBuf], { type: \"image/webp\" });\n                    var currentTime = _this.duration;\n                    _this.emit(\"webp\", { currentTime: currentTime, webp: webp });\n                });\n            }\n        }\n        else if (elm.type === \"m\" && elm.name === \"Cluster\" && elm.isEnd === false) {\n            this.firstVideoBlockRead = false;\n            this.firstAudioBlockRead = false;\n            this.emit_segment_info();\n            this.emit(\"cluster_ptr\", elm.tagStart);\n            this.lastClusterPosition = elm.tagStart;\n        }\n        else if (elm.type === \"u\" && elm.name === \"Timecode\") {\n            this.lastClusterTimecode = elm.value;\n        }\n        else if (elm.type === \"u\" && elm.name === \"TimecodeScale\") {\n            this.timecodeScale = elm.value;\n        }\n        else if (elm.type === \"m\" && elm.name === \"TrackEntry\") {\n            if (elm.isEnd) {\n                this.trackTypes[this.currentTrack.TrackNumber] = this.currentTrack.TrackType;\n                this.trackDefaultDuration[this.currentTrack.TrackNumber] = this.currentTrack.DefaultDuration;\n                this.trackCodecDelay[this.currentTrack.TrackNumber] = this.currentTrack.CodecDelay;\n            }\n            else {\n                this.currentTrack = { TrackNumber: -1, TrackType: -1, DefaultDuration: null, CodecDelay: null };\n            }\n        }\n        else if (elm.type === \"u\" && elm.name === \"TrackType\") {\n            this.currentTrack.TrackType = elm.value;\n        }\n        else if (elm.type === \"u\" && elm.name === \"TrackNumber\") {\n            this.currentTrack.TrackNumber = elm.value;\n        }\n        else if (elm.type === \"u\" && elm.name === \"CodecDelay\") {\n            this.currentTrack.CodecDelay = elm.value;\n        }\n        else if (elm.type === \"u\" && elm.name === \"DefaultDuration\") {\n            // media source api は DefaultDuration を計算するとバグる。\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=606000#c22\n            // chrome 58 ではこれを回避するために DefaultDuration 要素を抜き取った。\n            // chrome 58 以前でもこのタグを抜き取ることで回避できる\n            if (this.drop_default_duration) {\n                console.warn(\"DefaultDuration detected!, remove it\");\n                drop = true;\n            }\n            else {\n                this.currentTrack.DefaultDuration = elm.value;\n            }\n        }\n        else if (elm.name === \"unknown\") {\n            console.warn(elm);\n        }\n        if (!this.metadataloaded && elm.dataEnd > 0) {\n            this.metadataSize = elm.dataEnd;\n        }\n        if (!drop) {\n            this.chunks.push(elm);\n        }\n        if (this.logging) {\n            this.put(elm);\n        }\n    };\n    Object.defineProperty(EBMLReader.prototype, \"duration\", {\n        /**\n         * DefaultDuration が定義されている場合は最後のフレームのdurationも考慮する\n         * 単位 timecodeScale\n         *\n         * !!! if you need duration with seconds !!!\n         * ```js\n         * const nanosec = reader.duration * reader.timecodeScale;\n         * const sec = nanosec / 1000 / 1000 / 1000;\n         * ```\n         */\n        get: function () {\n            if (this.trackInfo.type === \"nothing\") {\n                console.warn(\"no video, no audio track\");\n                return 0;\n            }\n            // defaultDuration は 生の nano sec\n            var defaultDuration = 0;\n            // nanoseconds\n            var codecDelay = 0;\n            var lastTimecode = 0;\n            var _defaultDuration = this.trackDefaultDuration[this.trackInfo.trackNumber];\n            if (typeof _defaultDuration === \"number\") {\n                defaultDuration = _defaultDuration;\n            }\n            else {\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=606000#c22\n                // default duration がないときに使う delta\n                if (this.trackInfo.type === \"both\") {\n                    if (this.last2SimpleBlockAudioTrackTimecode[1] > this.last2SimpleBlockVideoTrackTimecode[1]) {\n                        // audio diff\n                        defaultDuration = (this.last2SimpleBlockAudioTrackTimecode[1] - this.last2SimpleBlockAudioTrackTimecode[0]) * this.timecodeScale;\n                        // audio delay\n                        var delay = this.trackCodecDelay[this.trackTypes.indexOf(2)]; // 2 => audio\n                        if (typeof delay === \"number\") {\n                            codecDelay = delay;\n                        }\n                        // audio timecode\n                        lastTimecode = this.last2SimpleBlockAudioTrackTimecode[1];\n                    }\n                    else {\n                        // video diff\n                        defaultDuration = (this.last2SimpleBlockVideoTrackTimecode[1] - this.last2SimpleBlockVideoTrackTimecode[0]) * this.timecodeScale;\n                        // video delay\n                        var delay = this.trackCodecDelay[this.trackTypes.indexOf(1)]; // 1 => video\n                        if (typeof delay === \"number\") {\n                            codecDelay = delay;\n                        }\n                        // video timecode\n                        lastTimecode = this.last2SimpleBlockVideoTrackTimecode[1];\n                    }\n                }\n                else if (this.trackInfo.type === \"video\") {\n                    defaultDuration = (this.last2SimpleBlockVideoTrackTimecode[1] - this.last2SimpleBlockVideoTrackTimecode[0]) * this.timecodeScale;\n                    var delay = this.trackCodecDelay[this.trackInfo.trackNumber]; // 2 => audio\n                    if (typeof delay === \"number\") {\n                        codecDelay = delay;\n                    }\n                    lastTimecode = this.last2SimpleBlockVideoTrackTimecode[1];\n                }\n                else if (this.trackInfo.type === \"audio\") {\n                    defaultDuration = (this.last2SimpleBlockAudioTrackTimecode[1] - this.last2SimpleBlockAudioTrackTimecode[0]) * this.timecodeScale;\n                    var delay = this.trackCodecDelay[this.trackInfo.trackNumber]; // 1 => video\n                    if (typeof delay === \"number\") {\n                        codecDelay = delay;\n                    }\n                    lastTimecode = this.last2SimpleBlockAudioTrackTimecode[1];\n                } // else { not reached }\n            }\n            // convert to timecodescale\n            var duration_nanosec = ((this.lastClusterTimecode + lastTimecode) * this.timecodeScale) + defaultDuration - codecDelay;\n            var duration = duration_nanosec / this.timecodeScale;\n            return Math.floor(duration);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    EBMLReader.prototype.addListener = function (event, listener) {\n        return _super.prototype.addListener.call(this, event, listener);\n    };\n    EBMLReader.prototype.put = function (elm) {\n        if (!this.hasLoggingStarted) {\n            this.hasLoggingStarted = true;\n            if (this.logging && this.logGroup) {\n                console.groupCollapsed(this.logGroup);\n            }\n        }\n        if (elm.type === \"m\") {\n            if (elm.isEnd) {\n                console.groupEnd();\n            }\n            else {\n                console.group(elm.name + \":\" + elm.tagStart);\n            }\n        }\n        else if (elm.type === \"b\") {\n            // for debug\n            //if(elm.name === \"SimpleBlock\"){\n            //const o = EBML.tools.ebmlBlock(elm.value);\n            //console.log(elm.name, elm.type, o.trackNumber, o.timecode);\n            //}else{\n            console.log(elm.name, elm.type);\n            //}\n        }\n        else {\n            console.log(elm.name, elm.tagStart, elm.type, elm.value);\n        }\n    };\n    return EBMLReader;\n}(events_1.EventEmitter));\nexports.default = EBMLReader;\n;\n;\n;\n;\n"]},"metadata":{},"sourceType":"script"}